[toc]

## 11 动画系统

- 动画系统为角色赋予自然的动作

### 11.1 角色动画的类型

#### 11.1.1 赛璐璐动画

- 所有游戏动画技术的前身都是传统动画或手绘动画，这些动画的动感由连续快速显示一系列静止图片所产生，这些图片称为帧，可将三维渲染想象为传统动画的电子形式，把一系列静止的全屏影像不断地向观众展示，以产生动感
- 赛璐璐动画是传统动画的一个种类，将一连串的透明塑料片放置于固定的手绘背景，即可产生动感，而无须不断重复绘制静态的背景
- 赛璐璐动画的电子版本称为精灵动画，
  - 精灵：一张小位图，叠在全屏的背景影像之上而不会扰乱背景，通常由专门的图形硬件绘制
  - 是二维游戏时代最主要的技术
  - 循环动画：一组帧通常被设计成重复播放也流畅的形式，此组动画以现在的说法可称为一个跑步周期，角色通常有多组循环动画周期，包括闲置周期、步行周期及跑步周期
- 如今精灵动画仍被用于低分辨率或远距离的物体上：
  - 物体是面向摄像机的四边形，每个四边形贴上一连串纹理位图，以产生动感

#### 11.1.2 刚性层阶式动画

- 角色由一堆刚性部分建模而成，人形角色通常会拆分成
  - 骨盆
  - 躯干
  - 上臂
  - 下臂
  - 大腿
  - 小腿
  - 手部
  - 脚步
  - 头部
- 这些刚性部分以层阶的形式彼此约束，类似于哺乳类动物以关节连接骨骼，这样能使角色自然地移动
- 一般的层阶会以骨盆为根，躯干和大腿是其直接子嗣，其他部分如下连接：
  - 骨盆 Pelvis
    - 躯干 Torso
      - 右上臂 UpperRightArm
        - 右前臂 LowerRightArm
          - 右手 RightHand
      - 左上臂 UpperLeftArm
        - 左前臂 LowerLeftArm
          - 左手 LeftHand
      - 头 Head
    - 右大腿 UpperRightLeg
      - 右小腿 LowerRightLeg
        - 右脚 RightFoot
    - 左大腿UpperLeftLeg
      - 左小腿 LowerLeftLeg
        - 左脚 LeftFoot

- 刚性层阶技术的问题：
  - 角色的身体会在关节位置产生碍眼的“裂缝”
    - 对于确实由刚性部件组成的机器人及机械，刚性层阶式动画效果不错
    - 但对有血有肉的人物，仔细看会发现问题

#### 11.1.3 每顶点动画及变形目标

- 刚性层阶式动画由于各部分为刚性的，往往显得不自然，真正希望实现的是能移动每个顶点，使三角形拉伸以产生更自然生动的动作
- 每顶点动画：
  - 动画师为网格的顶点添加动画，这些动作数据导出游戏引擎后，就能告诉引擎在运行时如何移动顶点，此技术能产生任何能想象到的网格变形
  - 但这是一种数据密集的技术，因为每个顶点随时间改变的动作信息都需要存储，因此在实时游戏中很少使用
- 变种：变形目标动画
  - 由动画师移动网格的顶点，但仅制作相对少量的固定极端姿势，在运行时将两个或以上的姿势混合，就能生成动画
  - 每个顶点的位置是简单地把每个极端姿势的位置进行线性插值而得的
  - 变形目标技术通常用于面部动画，因为人脸具有非常复杂的解剖结构，其动作大约由50组肌肉所驱动，动画师能使用变形目标动画去完全控制脸上的每个顶点，制作出细微及极端的移动，模拟面部肌肉组织
  - 由于计算能力的不断提升，有些工作室使用具有数百个关节的面部索具，取代变形目标；另一些工作室合并两种技术，使用关节锁具完成基本姿势，再利用变形目标做细节调整

#### 11.1.4 蒙皮动画

- 蒙皮动画中
  - 与刚性层阶动画类似，骨骼由刚性的“骨头”构建而成，但这些刚性部件不会渲染显示，始终被隐藏
  - 称为皮肤的光滑三角形网格会绑定于骨骼上，其顶点跟着关节的移动，蒙皮上的每个顶点可按权值绑定至多个关节，当关节移动时，蒙皮可以自然的拉伸

- 优点：
  - 允许组成网格的三角形做出变形
  - 高效性能、内存使用量小
  - 可以产生相当接近真实的皮肤和衣着的移动

#### 11.1.5 把动画方法视为数据压缩技术

- 可把最有弹性的动画系统想象成动画师能控制物体表面上无穷多的点，
  - 但此方法制作动画，会导致包含无穷多的数据
  - 理想的简化版本是控制三角形网格的顶点
    - 则实际上是将描述动画的信息加以压缩，限制只能移动顶点
    - 变形目标也可被想象为更进一步的压缩，其压缩方法是在系统中加入更多的约束：
      - 顶点只能在一组固定数目的预定义顶点位置间的线性路径中移动，
      - 骨骼动画是另一种通过加入约束来压缩顶点动画的方法，大量的顶点只能跟随相对少量的骨骼关节移动
- 权衡各种动画技术时，可将其当作压缩方法来考虑
  - 选择动画技术的目标：
    - 提供最佳压缩，但又不会产生不能接受的视觉瑕疵
  - 骨骼动画能提供最佳的压缩，因为每个关节的移动会扩大至多个顶点的移动
    - 角色的四肢大部分行为像刚体，故能有效地使用骨骼移动
    - 但面部的动作更加复杂，每个顶点的移动更加独立，若要使用骨骼的方式制作有说服力的动画，需要的关节就会接近网格的顶点数量，因而降低了骨骼动画作为压缩方法的效能，因此面部动画更多使用变形目标

### 11.2 骨骼

- 骨骼由刚性的关节层阶结构所组成
  - 骨头是关节间的空位

#### 11.2.1 骨骼层阶结构

- 骨骼关节形成层阶结构，也称树结构，蒙皮动画所用的关节层阶，通常和刚性层阶相同，人性角色的关节层阶可能如下：

  ![image-20210607112811038](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210607112811038.png)

- 通常为每个关节赋予$0\to(N-1)$的索引，由于每个关节有且有一个关节点，所以只要在每个关节存储其父关节的索引即可；根节点无父关节，其父索引通常被设为无效值，如$-1$

#### 11.2.2 在内存中表示骨骼

- 骨骼通常由一个细小的顶层数据结构表示，该结构有关节数组，关节的存储次序通常会保证每个子关节都位于其父关节之后，数组中的首个关节总是骨骼的根关节

- 动画数据结构中，使用关节索引引用关节

  - 如子关节通常以索引引用其父关节，
  - 在蒙皮三角形网络中，每个顶点使用索引引用其绑定关节
  - 优点：
    - 存储空间上，如果每个关节索引使用8位整数，则使用空间较小
    - 查找引用关节的时间上，索引可直接存取数组中所需的关节，效率高

- 关节的数据结构通常包含以下信息：

  - 关节名字：字符串或32位字符串散列标识符
  - 骨骼中其关节的索引
  - 关节的绑定姿势的逆变换
    - 绑定姿势：蒙皮网络顶点被绑定至骨骼时，关节的位置、定向及缩放

- 典型的骨骼数据结构：

  ```c++
  struct Joint
  {
      Matrix4x3 	m_invBindPose; 	// 绑定姿势的逆变换
      const char* m_name;			// 人可读的关节名
      U8 			m_iParent;		// 父索引，0xFF代表根节点
  };
  struct Skeleton
  {
      U32 		m_jointCount;	// 关节数目
      Joint* 		m_aJoint;		// 关节数组
  }
  ```

### 11.3 姿势

- 通过把角色身体摆出一连串离散、静止的姿势，并以通常每秒30或60个姿势的速度显示这些姿势（为相邻的姿势插值，而非直接显示），即可令角色产生动感
- 在骨骼动画中，骨骼的姿势直接控制网格顶点，将关节任意旋转、平移及缩放，就能为骨骼摆出各种姿势，
  - 一个关节的姿势被定义为关节相对某参考系的位置、定向和缩放
  - 关节的姿势通常以$4\times4$或$4\times3$矩阵表示，或表示为SQT数据结构
- 骨骼的姿势是所有关节姿势的集合，并通常简单地以SQT数组表示

#### 11.3.1 绑定姿势

- 三维网格绑定至骨骼之前的姿势，又称参考姿势、放松姿势、T姿势（T-pose）

  - 此姿势中的四肢远离身体，容易将顶点绑定至关节

  ![image-20210607140941647](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210607140941647.png)

#### 11.3.2 局部姿势

- 局部姿势：最常见的关节姿势是相对于父关节来指定的，相对父关节的姿势能令关节自然地移动，称为局部姿势

- 局部姿势存储为SQT格式

- 数学上，关节姿势表示为仿射变换，第$j$个关节表示为$4\times4$仿射变换矩阵$\bold P_j$

  $\bold P_j=\left[\begin{array}{}\bold S_j\bold R_j&0\\\bold T_j&1\end{array}\right]$

  - $\bold S_j$：对角缩放矩阵
  - $\bold R_j$：旋转矩阵
  - $\bold T_j$：平移矢量

- 整个骨骼的姿势表示为所有关节姿势的集合：

  $\displaystyle \bold P^{skel}=\{\bold P_j|_{j=0}^{N-1}\}$

##### 11.3.2.1 关节缩放

- 允许的缩放类型：
  - 某些引擎不允许关节缩放，则忽略$\bold S_j$，将其视为单位矩阵
  - 某些引擎只允许统一缩放，则$\bold S_j$视为标量$s_j$
  - 某些引擎支持非统一缩放，则缩放可紧凑地表示为3元素矢量$\bold s_j=\begin{array}{}[s_{jx}&s_{jy}&s_{jz}]\end{array}$
- 限制缩放的好处：
  - 减少内存开销
  - 限制使用统一缩放，可以避免包围球不会变换为椭球体，以简化按每关节计算的平截头体剔除及碰撞测试

##### 11.3.2.2 在内存中表示关节姿势

- 关节姿势通常表示为SQT格式：

  ```c++
  struct JointPose
  {
  	Quaternion 	m_rot;		// Q
      Vector3 	m_trans;	// T
      F32			m_scale;	// S,统一缩放
  }
  ```

  或

  ```c++
  struct JointPose
  {
  	Quaternion 	m_rot;		// Q
      Vector3 	m_trans;	// T
      Vector3		m_scale;	// S,非统一缩放
  }
  ```

- 整个骨骼的局部姿势表示为：

  ```c++
  struct SkeletonPose
  {
  	Skeleton*	m_pSkeleton;	// 骨骼 + 关节数量
      JointPose* 	m_aLocalPose;	// 多个局部关节姿势
  }
  ```

  - 其中， m_aLocalPose数组是动态分配的，该数组刚好可容纳匹配骨骼内关节数目的JointPose

##### 11.3.2.3 把关节姿势当作基的变更

- 局部关节姿势是相对其直属的父关节指定的，任何仿射变换都可想象为把点或矢量从一个坐标系变换至另一个坐标系，当把关节姿势变换$\bold P_j$施于以关节$j$坐标系表示的点或矢量时，其变换结果是以父空间表示的该点的矢量
- 使用下标表示变换的方向：
  - 关节姿势将点和矢量从子关节的空间（C）变换至父关节的空间（P），因此将此变换写为$(\bold P_{C\to P})_j$
  - 另一种方式是引入一个函数$p(j)$，它会回传关节$j$的父索引，则可记关节$j$的局部姿势为$\bold P_{j\to p(j)}$
- 当要以相反的方向变换点及矢量（父关节的空间变换至子关节的空间），此变换就是局部关节姿势的逆变换：
  - $\bold P_{p(j)\to j}=(\bold P_{j\to p(j)})^{-1}$

#### 11.3.3 全局姿势

- 全局姿势：将关节姿势表示为模型空间或世界空间

- 数学上，某关节的模型空间姿势$(j\to M)$可通过从该关节遍历至根节点时，在每个关节乘上其局部姿势$(j\to p(j))$算出，如：

  ![image-20210607151231907](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210607151231907.png)

  - 关节$J_2$的模型空间姿势可表示为：
    - $\bold P_{2\to M}=\bold P_{2\to 1}\bold P_{1\to 0}\bold P_{0\to M}$
  - 关节$J_5$的模型空间姿势可表示为：
    - $\bold P_{5\to M}=\bold P_{5\to 4}\bold P_{4\to 3}\bold P_{3\to 0}\bold P_{0\to M}$
  - 任意关节$j$的全局姿势：
    - $\displaystyle \bold P_{5\to M}=\prod_{i=j}^0P_{i\to p(i)}$
    - 每次乘法迭代可理解为$i$变成$p(i)$即i的父关节，且$p(0)\equiv M$

##### 11.3.3.1 在内存中表示全局姿势

- 扩展SkeletonPose，以包含全局姿势

  ```c++
  struct SkeletonPose
  {
  	Skeleton*	m_pSkeleton;	// 骨骼 + 关节数量
      JointPose* 	m_aLocalPose;	// 多个局部关节姿势
      Matrix44*	m_aGlobalPose;	// 多个全局关节姿势
  }
  ```

  - 其中m_aGlobalPose数组是基于骨骼中的关节数目动态分配的

### 11.4 动画片段

- 比较动画电影与游戏中的动画：
  - 动画电影：
    - 整个场景以一串很长的、连续的帧来产生动画
  - 游戏：
    - 游戏角色的移动必须被拆分为大量小粒度的动作，被称为动画片段，有时也简称为动画
    - 每个片段都能令角色表现一个有明确界定的动作。
      - 有些片段被设计成循环形式，如跑步；有的则只会播放一次，如跌倒
      - 有些片段影响角色全身，如跳跃；有的则只影响身体的一部分，如挥手
    - 一个角色的动作一般会被拆分为上千个片段
    - 例外：当角色进入游戏中的非互动的部分（游戏内置电影IGC、非交互连续镜头NIS、全动视频FMV）时，这些非互动序列制作方法类似动画电影
      - IGC、NIS：游戏引擎渲染的非互动序列
      - FMV：预先渲染至MP4、WMV或其他的视频文件类型，然后在运行时由引擎内的全屏电影播放器播放
    - 非互动序列的变种是半互动序列：快速反应事件QTE，QTE内玩家必须在非互动序列中的正确时间按键，才能看到成功的动画并继续，否则播放失败动画

#### 11.4.1 局部时间线

- 每个动画片段都有一条局部时间线，该时间线使用自变量$t$表示，片段开始时$t=0$，结束时$t=T$，$T$为片段持续时间

- 变量$t$的每个值称为时间索引

  ![image-20210607154337481](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210607154337481.png)

##### 11.4.1.1 姿势插值及连续时间

- 帧展示的频率并不一定等于动画师制作的姿势的播放频率

  - 动画师会在片段中指定的时间点设定一些重要的姿势，称为关键姿势或关键帧

  - 计算机会采用线性或基于曲线的插值计算中间的姿势

    ![image-20210607154727501](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210607154727501.png)

  - 由于动画引擎能够对姿势插值，因此可以在片段中的任何时间采样，而不一定要在整数帧索引上采样，故动画的时间线是连续的，即$t$为浮点数 

- 动画电影的帧率为定值，故只会在整数帧上采样；而实时游戏中，游戏的帧率会受CPU/GPU的负载的影响，使角色动作与原本制作动画的速率不同，故几乎不会在整数帧索引上采样

- 游戏动画的时间是连续的，且可改变比例的

##### 11.4.1.2 时间单位

- 时间变量$t$为浮点数，最好用秒作为时间单位
- 若定义了帧的持续时间，则时间也可以使用帧作为度量单位，典型的帧持续时间为$1/30s$或$1/60s$
- 避免将时间定义为整数，时间应为浮点数、定点数或非常小的子帧时间间隔的整数
- 时间的度量应当具有足够的分辨率，以计算帧之间的结果或改变动画播放速率

##### 11.4.1.3 比较帧与采样

- 每秒30帧，包含31个采样
- 以帧表示$1/30s$或$1/60s$的持续时间
- 采样表示其中的数据点

##### 11.4.1.4 帧、采样及循环片段

- 循环：把动画片段设计为不断重复播放
- 为保证片段无缝衔接，最后一个采样与第一个采样相同，因此循环片段的最后一个采样是冗余的，故许多游戏引擎会略去最后一个采样
- 非循环动画：
  - N帧，N+1个采样
- 循环动画：
  - N帧，N个采样

##### 11.4.1.5 归一化时间（相位）

- 归一化时间u，$u=0$代表动画的开始，$u=1$代表动画的结束，不管动画的持续时间$T$为多长，有时归一化时间被称相位
- 当同步两个或以上的动画片段，且其持续时间不同时，可使用归一化时间确保两个动画的播放速度匹配：
  - 将两段动画的归一化起始时间匹配，再使用相同的归一化速率推进，使两片段保持同步
  - 较绝对时间索引：更易实现，且不易出错

#### 11.4.2 全局时间线

- 每个角色都有一个全局时间线，时钟在角色诞生于游戏世界或关卡、游戏开始时启动

- 播放动画可以视为将片段的局部时间映射至角色的全局时间，记为$\tau$：

  ![image-20210607161420238](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210607161420238.png)

- 播放循环动画即将片段复制无限次，并前后相连至全局时间线；也可将动画循环播放有限次，即复制片段有限次首尾相接置于全局时间线

- 在片段中调整时间比例，即可倍速播放片段

  - 实现：将片段置于全局时间线上时缩放其比例，即播放速率，使用变量$R$表示
  - 若2倍速播放，则$R=2$，在将局部时间线放置在全局时间线上时，将局部时间线压缩为正常长度的一半
  - 判断倒转，即$R=-1$

- 局部时间线至全局时间线的映射方法：

  - 将动画映射至全局时间线需要的信息：
    - 全局起始时间$\tau_{start}$
    - 播放速率$R$
    - 持续时间$T$
    - 循环次数$N$
  - 基于以上信息，构建的局部时间线至全局时间线及反向的映射为：
    - $\tau =\tau_{start} + \frac{1}{R}t$
    - $t=R(\tau-\tau_{start})$
  - 从全局时间映射至局部时间后要保证时间的合法性：
    - 若动画非循环（$N=1$）：
      - 在使用$t$为片段采样一个姿势之前，需要先将$t$剪裁至合法范围$[0,T]$
    - 若动画无限循环（$N=\infty$）：
      - 可以用$t$对持续时间$T$取模，以得到合法范围的时间
    - 若动画有限循环（$0<N <\infty$）
      - 则需先将$t$剪裁至$[0,NT]$的范围，再将结果对$T$取模，得到合法范围的时间

- 多数游戏引擎直接使用局部动画时间线，而不使用全局时间线，但使用全局时间线会使得同步动画变得更加直观

#### 11.4.3 比较局部和全局时钟

- 记录时间索引的方法：
  - 局部时钟：
    - 每个片段都有其局部时钟，时钟通常用秒/帧/归一化时间为单位，以浮点小数形式存储
    - 片段开始播放时，局部时间$t$被设置为0
    - 随时间推移，每个片段各自的局部时钟向前推进
    - 若片段有非正常播放速率，则局部时钟再推进时以$R$缩放
  - 全局时钟：
    - 角色含有全局时钟，通常以秒为单位，每个片段记录其开始播放时的全局时间$\tau_{start}$，片段的局部时钟由上述公式计算，而非直接存储于片段之中
- 比较：
  - 局部时钟：
    - 简单，动画系统的显然选择
  - 全局时钟：
    - 适用于同步动画，无论是单个角色本身的同步还是场景中多个角色的同步

##### 11.4.3.1 用局部时钟同步动画

- 同步两个或以上的片段，需要在完全相同的游戏时间对其播放，但若播放命令来自多个不同子系统，就会产生一定的延迟：
  - 如玩家出拳的动画在玩家子系统内播放，NPC受击动画由AI子系统播放，若游戏循环内AI子系统的代码先于玩家子系统代码执行，则玩家出拳和NPC的反应就会存在一帧的延迟，反之亦然
- 若两子系统之前的通信使用消息传送（事件）系统，则还会有额外的延迟、

##### 11.4.3.2 用全局时钟同步动画

- 全局时钟方法有助于解决同步问题，所有片段的时间线都有相同的原点，在多个动画中，若其全局的开始时间在数值上相同，则这些片段在开始时就是完全同步的。若片段的播放速率相同，则片段一直同步
- 全局同步需要确保两个角色的全局时间相互匹配：这可根据两个角色的全局时钟只差，调整两个全局开始时间；或令游戏中所有角色共享同一个时钟

#### 11.4.4 简单动画的数据格式

- 动画数据一般是离散地以每秒30个或60个骨骼姿势地的速率采样而得，一个采样由骨骼中每个关节的完整姿势组成。这些关节姿势通常存储为SQT格式，对每个关节$j$：

  - 缩放：标量$S_j$或三维矢量$\bold S_j$
  - 旋转：四元数$Q_j$
  - 平移：三维矢量$\bold T_j$

- 即一个动画由每关节至多10个通道（即SQT的10个分量）组成

- 动画片段的表示：

  ```c++
  struct JointPose
  {
  	Quaternion 			m_rot;			// Q
      Vector3 			m_trans;		// T
      Vector3				m_scale;		// S,非统一缩放
  }
  
  struct Joint
  {
      Matrix4x3 			m_invBindPose; 	// 绑定姿势的逆变换
      const char* 		m_name;			// 人可读的关节名
      U8 					m_iParent;		// 父索引，0xFF代表根节点
  };
  struct Skeleton
  {
      U32 				m_jointCount;	// 关节数目
      Joint* 				m_aJoint;		// 关节数组
  }
  
  // 一次采样 
  struct AnimationSample
  {
      JointPose* 			m_aJointPose;	// 关节姿势数组
  }
  
  // 完整动画
  struct AnimationClip
  {
      Skeleton* 			m_pSkeleton;
      F32					m_framesPerSecond;
      U32					m_frameCount;
      AnimationSample*	m_aSamples;		// 采样数组
      bool 				m_isLooping;
  }
  ```

- 每个动画片段都是为特点骨骼设计的，通常不会用于其他骨骼，如上述例子中AnimationClip数据结构中含有其骨骼的引用m_pSkeleton（真实的引擎中可能使用唯一的骨骼表示符，此时引擎需提供快速、方便的方法以标识符查找骨骼）

- m_aJointPose的数组长度已假定和骨骼的关节数相同

- m_aSamples数组的采样数目由帧数及该片段是否用于循环决定的，如前所述

  - 非循环动画的采样数目为m_frameCount + 1
  - 循环动画的采样数目为m_frameCount

- 真实引擎中，还会对动画数据进行压缩，以节省内存

##### 11.4.4.1 动画重定目标

- 尽管一个动画通常仅兼容特定骨骼，但若多个骨骼近似（含有不影响主要层次结构的子关节），则也可应用于其余骨骼，此时需要引擎在对于其余骨骼播放动画时忽略动画中未能与骨骼匹配的关节
- 更先进的技术：将为一个骨骼设计的动画重定目标至不同骨骼

#### 11.4.5 连续的通道函数

- 动画片段的采样用于定义随时间改变的连续函数（1个自变量t，10个标量因变量）

- 但在实践中许多游戏引擎只会在采样间进行线性插值，使用元连续函数的分段线性逼近

  ![image-20210607173910994](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210607173910994.png)

#### 11.4.6 元通道

- 在动画的基础10通道外增加额外的元通道数据，以存储额外的信息，将游戏专用的信息编码，同时和动画同步，且无需将信息以骨骼姿势存储

- 常见的元通道：

  - 事件触发器

    - 当动画的局部时间经过触发器时，触发器的事件就会交送游戏引擎，引擎按需处理这些事件

    ![image-20210607174544587](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210607174544587.png)

  - 定位器：

    - 可以和骨骼关节一起设置动画，由于定位器和关节一样为仿射变换，故这些特殊关节可用于记录游戏中任何物体的位置及定向
    - 定位器的常见用法是在动画中设置摄像机的位置及角度，可将摄像机绑定至某个定位器，然后与角色的关节一起设置动画，将摄像机的定位器导出后，就能在游戏中播放动画时移动摄像机，摄像机的视野及其他摄像机属性也可设置动画，其数据存储在一个或以上的浮点通道中

  - 其余非关节动画通道的例子：

    - 纹理坐标滚动
    - 纹理动画
    - 含动画的材质参数
    - 含动画的光源半径
    - 其他随时间改变，并以某种形式和动画同步的参数

### 11.5 蒙皮及生成矩阵调色板

- 蒙皮：将三维网格顶点联系至骨骼

#### 11.5.1 每顶点的蒙皮信息

- 蒙皮用的网格通过其顶点系上骨骼，每个顶点可以绑定（bing）至一个或多个关节：

  - 绑定至一个关节：完全跟随该关节移动
  - 绑定至多个关节：逐一绑定至每个关节后位置的加权平均

- 将网格蒙皮至骨骼，建模师需为每个顶点提供的信息：

  - 顶点要绑定到的（一个或多个）关节索引
  - 每个绑定的关节的权重（各个顶点的权值和为1）

- 游戏引擎通常限制每个顶点能绑定的关节数目，典型数量为每个顶点4个关节：

  - 4个8位关节索引可被包裹为一个32位字
  - 每顶点使用2个、3个及4个关节的质量差异容易区分，但超过4个关节，则多数人很难区分

- 由于关节权值的和为1，故最后一个权重可以略去，典型的蒙皮顶点数据结构如下：

  ```c++
  struct SkinnedVertex
  {
      float	m_position[3];		// 顶点坐标
      float	m_normal[3];		// 法线向量
      float	m_u, m_v;			// 纹理坐标
      U8		m_jointIndex[4];	// 关节索引
      float 	m_jointWeight[3];	// 关节权重，略去最后一个
  }
  ```

#### 11.5.2 蒙皮涉及的数学知识

- 蒙皮网格的顶点随其绑定的关节移动，在数学上，要求一个矩阵，该矩阵能把网格顶点从原来位置（绑定姿势）变换至骨骼当前的姿势，称为蒙皮矩阵
- 与网格顶点相同，蒙皮顶点的位置在模型空间定义，无论骨骼的姿势，因此蒙皮矩阵将把顶点从绑定姿势的模型空间变换至当前姿势的模型空间，而不是变更基

##### 11.5.2.1 单个关节骨骼的例子

![image-20210607193456542](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210607193456542.png)

- 求蒙皮矩阵的方法：
  - 顶点绑定至关节的位置时，在该关节坐标空间中是不变的
  - 首先将顶点在模型空间中的绑定姿势位置转换至关节空间
  - 再把关节移至当前姿势
  - 最后把该顶点转回模型空间
- 数学的形式：
  - 对一个顶点在其绑定位置，有其在模型空间内的坐标矢量$\bold V_M^B$
  - 首先将顶点位于模型空间内的坐标转变至关节空间内的坐标：
    - $\bold v_j=\bold v_M^B\bold B_{M\to j}$
  - 而模型空间转换至关节空间为关节空间至模型空间的逆转换，且关节空间至模型空间的转换为绑定姿势矩阵：
    - $\bold v_j=\bold v_M^B(\bold B_{j\to M})^{-1}$
  - 以矩阵$\bold C_{j\to M}$表示关节的当前姿势，则将$\bold v_j$从关节空间转换回模型空间：
    - $\bold v_M^C=\bold v_jC_{j\to M}$
  - 带入$\bold v_j$，展开有：
    - $\bold v_M^C\\=\bold v_M^B(\bold B_{j\to M})^{-1}\bold C_{j\to M}\\=\bold v_M^B\bold K_j$
  - 则联合后的矩阵$\bold K_j=(\bold B_{j\to M})^{-1}\bold C_{j\to M}$为蒙皮矩阵

##### 11.5.2.2 扩展至多个关节的骨骼

- 以上推导其实可以施于任何骨骼中的任何关节，为扩展以上的推导，需要做两个小调整
  - 确保矩阵$\bold B_{j\to M},\bold C_{j\to M}$使用各层子关节至其父关节的递推式计算完整
  - 计算一组蒙皮矩阵$\bold K_j$，其中每个矩阵对应的第$j$个关节，此数组称为矩阵调色板，当渲染一个蒙皮网格时，将全部的蒙皮矩阵传送至渲染器，渲染器对每个需要蒙皮的顶点查找其被绑定至的关节的蒙皮矩阵，并用该矩阵把顶点从绑定姿势变成当前姿势
- 在计算时的优化：
  - 绑定姿势逆矩阵存储于骨骼，为常量
- 多个关节的骨骼的计算流程：
  - 首先读取全身各节点的绑定姿势逆矩阵$\bold B_{j\to M}^{-1}$
  - 再将变换姿势，并计算每个关节的局部姿势$\bold C_{j\to p(j)}$
  - 通过局部姿势的递推转换，计算各个关节的全局姿势$C_{j\to M}$
  - 将全局姿势乘以对应的绑定姿势的逆矩阵，生成每个关节的蒙皮矩阵$\bold K_j$
  - 再将全身的顶点分别乘以其对应绑定的蒙皮矩阵

##### 11.5.2.3 引入模型至世界变换

- 每个顶点最终都会由模型空间变换至世界空间，有些引擎会预先乘以物体的模型至世界变换，这对每个蒙皮顶点可以减少一个矩阵乘法：
  - $(\bold K_j)_W=(\bold B_{j\to M})^{-1}\bold C_{j\to M}\bold M_{M\to W}$
- 某些情况下不提前变换至世界空间：
  - 同时对多个角色播放单个动画
  - 此时将模型至世界的变换剥离，以便将单个矩阵调色板应用至群众中的多个角色

##### 11.5.2.4 把顶点蒙皮至多个关节

- 分别将顶点蒙皮至每个关节，产生对于每个节点的模型空间位置
- 再以权值对多个位置进行加权平均，得到最终位置
- 权重和应为1，若不为1，应由管道进行归一化
- 对于N个数值$a_0$至$a_{N-1}$的对应权重$w_0$至$w_{N-1}$，并且$\sum w_i=1$，则数值的加权平均公式为：
  - $\displaystyle a=\sum_{i=0}^{N-1}w_ia_i$
- 同理对一个顶点蒙皮至$N$个关节，关节索引为$j_0-j_{N-1}$，权重为$w_0-w_{N-1}$，算式延伸为：
  - $\displaystyle \bold v_M^C=\sum_{i=0}^{N-1}w_i\bold v_M^B\bold K_{j_{i}}$
    - 其中$\bold K_{j_{i}}$是关节$j_i$的蒙皮矩阵

### 11.6 动画混合

- 动画混合：令一个以上的动画片段对角色最终姿势起作用的技术，即将两个或多个输入姿势结合，产生骨骼的输出姿势
  - 混合通常结合某个时间点的两个或以上的姿势，并生成同一时间点的输出
  - 混合用作结合两个或两个以上的动画，自动产生大量新动画，而无须手工制作这些动画
    - 如混合负伤及无负伤的步行动画，以得到不同程度负伤的动画
  - 混合也可以用于求出不同时间点的两个已知姿势之间的姿势
    - 当需要取得角色某时间点的姿势，但该时间点不是动画数据中的采样帧时，即可使用这种动画混合
  - 也可使用时间上的动画混合，通过再短时间内把来源动画逐渐混合至目标动画，即可把某动画平滑地过渡至另一动画

#### 11.6.1 线性插值混合

- 给定N个关节的骨骼，以及两个骨骼姿势$\displaystyle \bold P_A^{skel}={(\bold P_A)_j|_{j=0}^{N-1}},\bold P_B^{skel}={(\bold P_B)_j|_{j=0}^{N-1}}$，希望求得两极端的中间姿势$\bold P_{LERP}^{skel}$，方法之一为，对这两个来源姿势中每个关节的局部姿势进行线性插值，表示如下：

  - $(\bold P_{LERP})_j\\=LERP[(\bold P_A)_j,(\bold P_B)_j,\beta]\\=(1-\beta)(\bold P_A)_j+\beta(\bold P_B)_j$
    - $\beta$称为混合百分比，$\beta=0or1$即姿势为两种极端情况

- 对关节进行插值，但对矩阵插值难度较大，故通常使用SQT格式表示局部姿势，因此即对SQT中的每个部分进行插值：

  - 位移矢量$\bold T$：

    - $\bold T_{{LERP}_j}\\=LERP[(\bold P_A)_j,(\bold P_B)_j,\beta]\\=(1-\beta)(\bold T_A)_j+\beta(\bold T_B)_j$

  - 旋转四元数$Q$：

    - $Q_{LERP_j}=normalize((1-\beta)(Q_A)_j+\beta(Q_B)_j)$

      或

    - $\displaystyle Q_{SLERP_j}=\frac{\sin(1-\beta)\theta)}{\sin\theta}(Q_A)_j+\frac{\sin(\beta\theta)}{\sin\theta}(Q_B)_j$

  - 缩放标量$S_j$或$\bold S_j$：

    - $S_{LERP_j}=(1-\beta)(S_A)_j+\beta(S_B)_j$

- 对两个骨骼姿势进行线性插值时，自然的中间姿势通常是令关节在其父关节中间进行插值，即

  - 姿势混合通常在局部姿势进行

- 由于姿势混合在局部姿势进行，故每个关节姿势的线性插值完全独立于同一骨骼上的其他关节插值：

  - 线性插值可完全并行的计算（但一般一个骨骼实际只有上百个关节，将一个角色的关节并行插值可能降低内存存取的连贯性，导致性能下降；如果游戏中有大量角色，可以考虑以角色（骨骼）为最小单位进行并行处理）

#### 11.6.2 线性插值混合的应用

##### 11.6.2.1 时间性混合

- 通过改变$\beta$获取两个时间点的采样之间某一点的中间姿势
- 给定两个在时间点$t_1,t_2$的姿势采样，以下算式可以求得位于此期间时间点$t$的姿势：
  - $\bold P_j(t)=(1-\beta(t))\bold P_j(t_1)+\beta(t)\bold P_j(t_2)$
  - 混合因子$\beta(t)$，由$t$在两个时刻中间的比例决定：
    - $\displaystyle \beta(t)=\frac{t-t_1}{t_2-t_1}$

##### 11.6.2.2 动作连续性

- 游戏角色的动画由大量细粒度动画片段拼接而成，对于单个动作片段的自然真实较为容易，但要将一个片段过渡至另一片段的质量做到与单个动画一致是很难的

- 理想情况下，对于过渡中也应该保证骨骼中的每个关节移动时所描绘出的三娃路径不包含突然的跳跃，称为$C^0$连续：

  ![image-20210608120512909](C:\Users\89776\AppData\Roaming\Typora\typora-user-images\image-20210608120512909.png)

- 同时，路径之外，其第一导数（速度）曲线也应该连续，又称$C^1$连续，如果保证更高阶的连续性，则角色的动作会显得更加真实

- 通常难以达到数学上严格的$C^1$或以上的连续性，但可以使用LERP的动画混合达到不错的$C^0$动作连续性，这种混合也可以较好的逼近$C^1$连续性

- LERP在应用至过渡片段时，被称为淡入/淡出，LERP混合可能产生一些瑕疵（如脚滑）

- 对两个动画进行淡入/淡出，要把两个片段的时间线适度重叠

- 在开始时间$t_{start}$时，混合百分比$\beta$为0，混合之初只能看见片段A；然后逐步递增$\beta$，直至时间$t_{end}$时$\beta$为1，此时只能看见片段B

- 两种常见的淡入/淡出过渡方法如下：

  - 平滑过渡：
    - AB同时播放，同时递增$\beta$
    - 为了更好的效果，需要两个片段都为循环动画，且两个片段应该同步至手脚位置大致匹配
  - 冻结过渡：
    - 开始播放B时，片段A的局部时钟停顿，以停顿的这一帧中A的骨骼每次与B中播放的采样进行混合
    - 适用于混合两个不相关，且不难在时间上同步的片段

  ![image-20210608133732983](C:\Users\89776\AppData\Roaming\Typora\typora-user-images\image-20210608133732983.png)

- 为了得到更平滑的过渡，可以令$\beta$按时间的三次函数变化：

  ![image-20210608133747083](C:\Users\89776\AppData\Roaming\Typora\typora-user-images\image-20210608133747083.png)

  - 表达式如下：
    - $\displaystyle u=\frac{t-t_{start}}{t_{end}-t_{start}}$
    - $v=1-u$
    - $\beta(t)=(v^3)\beta_{start}+(3v^2u)T_{start}+(3vu^2)T_{end}+(u^3)\beta_{end}$
    - 令切线$T_{start},T_{end}$被设为对应的混合因子$\beta_{start},\beta_{end}$
    - $\beta(t)=(v^3+3v^2u)\beta_{start}+(3vu^2+u^3)\beta_{end}$

- 核心姿势：
  - 不需要混合即可产生连续动作的方法：确保某片段的最后姿势能匹配后续片段的首个姿势
  - 实践中通常制定一组核心姿势，如包括一个直立的核心姿势、一个蹲下姿势、一个躺下姿势等
    - 只要能确保角色的每个动画片段从某核心姿势开始，
    - 再以某核心姿势结束，
    - 就能简单地把核心姿势匹配的片段连接成具有$C^0$连续性的动画
    - $C^1$或更高阶的连续性动画也可做到，只要确保角色再片段结束时动作能平滑地过渡至后续片段开始时的动作，具体如将一段平滑的动画再将其切分为两个或两个以上的动画片段

##### 11.6.2.3 方向性运动

- 基于LERP的动画混合通常应用在角色运动中，真实人类在步行/跑步中有两种方式改变移动方向：

  ![image-20210608140211320](C:\Users\89776\AppData\Roaming\Typora\typora-user-images\image-20210608140211320.png)

  - 轴转移动：
    - 转身改变方向，一直面向移动方向
  - 靶向移动：
    - 保持面向某方向，但同时可以朝前后左右步行

- 轴转移动：

  - 简单播放向前运动循环片段，同时以垂直轴旋转整个角色
  - 为更加真实，可使角色在转向时不保持完全笔直，稍微产生一定倾斜，但这会导致角色内脚插入地面，外脚翘起
  - 因此可以使用3个向前步行或跑步的动画，一个完全向前，一个极端左转，一个极端右转，再使用LERP对这些动画进行混合，以产生任意想要的倾斜角

- 靶向移动：

  - 为实现靶向移动，需要制作3种不同的循环动画片段，包括向前、向左及向右移动，将这3个片段排列再一个半圆圆周上：

    ![image-20210608141809574](C:\Users\89776\AppData\Roaming\Typora\typora-user-images\image-20210608141809574.png)

  - 只要使角色面对方向对齐至$0°$，就能在半圆上求得移动方向，然后旋转该角度上的两个相邻片段以LERP方式混合，混合百分比$\beta$由移动角度和相邻片段的角度求得

  - 在此并未在混合中包含向后移动以形成一个全周的混合：

    - 左右移动和向后移动的直接混合，由于左右移动时左右脚的前后不一致会出现腿部穿模
    - 一种解决方法是定义两个半圆混合，一个用作向前移动，一个用作向后移动，再为这两个半圆分别制作两组适合混合的左右移动动画，当从一个半圆切换至另一半圆时，可以加入明确的过渡动画，使角色调整步伐及跨步

#### 11.6.3 复杂的线性插值混合

- 真实的游戏引擎中，角色会使用不同种类的复杂混合，以达到不同的目的，为了更易使用，通常将几个常见的复杂混合封装起来

##### 11.6.3.1 泛化的一维线性插值混合

![image-20210608144443343](C:\Users\89776\AppData\Roaming\Typora\typora-user-images\image-20210608144443343.png)

- 将LERP扩展至多于两个动画片段
- 定义新的混合参数$b$，可任意指定此参数的范围
- 同时将任意数量的片段置于此范围中的某点之上
- 对给定的任意$b$值，选取两个距离$b$值最近的片段，并用算式混合两者，记两片段分别位于点$b_1,b_2$，则混合百分比$\beta$如下：
  - $\displaystyle \beta(b)=\frac{b-b_1}{b_2-b_1}$
- 靶向移动为一维LERP的特例

##### 11.6.3.2 简单的二维线性插值混合

- 平滑的同时改变角色动作的两个方面
- 若所需的二维混合只涉及4个动画片段，且这些片段位于一个正方形区域的四个角，则可以用3个一维混合求得混合姿势
- 令广义混合因子$\bold b=\begin{array}{}[b_x&b_y]\end{array}$，则混合过程如下：
  - 利用水平混合因子$b_x$求出两个中间姿势
  - 利用垂直混合因子$b_y$求出两个中间姿势的混合

##### 11.6.3.3 三角形的二维线性插值混合（？）

- 使用3维LERP混合三个动画片段：
  - $(\bold P_{LERP})_j=\alpha(\bold P_0)_j+\beta(\bold P_1)_j+(1-\alpha-\beta)(\bold  P_2)_j$

- 类似在三角形内任意找到一点：

  - $\bold b=\alpha\bold b_0+\beta\bold b_1+\gamma \bold b_2$
  - $\alpha+\beta+\gamma=1$

  ![image-20210608155256038](C:\Users\89776\AppData\Roaming\Typora\typora-user-images\image-20210608155256038.png)

##### 11.6.3.4 泛化的二维线性插值混合

- 利用Delaunay三角剖分技术，从多个动画片段位置$b_i$求出一组三角形，得到这些三角形后从中寻找包围混合点$b$的三角形，再在该三角形上使用三片段LERP

#### 11.6.4 骨骼分部混合

- 骨骼分部混合：如人可独立控制身体的不同部位
- 对正常的LERP，允许每个关节设置不同的混合百分比
- 即对每个关节$j$定义一个独立的混合百分比
- 整个骨骼的混合百分比集合：${\beta_j}|_{j=0}^{N-1}$，被称为混合遮罩
  - 因为可以将某些关节的混合百分比设置为0，以掩盖这些关节
    - 如令角色挥手，首先有全身动作步行、跑步及站立
    - 再创建一挥手动作，
    - 则可以创建一个混合遮罩，在遮罩中，将右肩、右肘、右腕及右手手指关节的混合百分比设为1，其他关节百分比设为0
    - 以此，在角色行动时使用此混合遮罩，即可让角色在移动的同时挥动右手
- 骨骼分部混合会导致不自然的角色动作：
  - 相连关节的混合因子突变，导致身体部分动作与其他动作分离
    - 可以逐渐改变混合因子，而不是突变（如自树的根至叶依次增大混合系数）
  - 现实中人体的动作并非完全独立，当人在跑步时，玩家会更倾向于认为挥手会更加晃动，但这无法被骨骼分部混合解决

#### 11.6.5 加法混合

- 区别片段动画：两段正常动画的区别，存储一个姿势至另一个姿势的改变，区别动画可以被加进普通的动画片段，以产生有趣的姿势和动作变化
- 输入两片段：来源片段（S）和参考片段（R），则区别片段定义为$D=S-R$
  - 若将区别片段$D$加入原本的参考片段，则将取回来源片段
  - 若将某比例的$D$加入原本的参考片段，则可以产生介于$R$和$S$之间的动画，如同使用LERP为两个极端片段找出中间动画
- 但加法混合技术可以在制作一个区别片段后，将其加入其他不相关的片段（目标动画，T），而不仅限于原来的参考片段

##### 11.6.5.1 数学公式

- 关节姿势是一个$4\times 4$的仿射矩阵$\bold P_{C\to P}$，此矩阵会把点或矢量从子关节的局部空间变换至其父关节的空间
- 对矩阵，等价于标量减法的运算为乘以逆矩阵，故给定骨骼中每个关节$j$的来源姿势$\bold S_j$及参考姿势$\bold R_j$，区别姿势$\bold D_j$可定义如下：
  - $\bold D_j=\bold S_j\bold R_j^{-1}$
- 将区别姿势$\bold D_j$加进目标姿势$\bold T_j$会产生新的加法姿势$\bold A_j$，只需要简单的串接区别变换及目标变换：
  - $\bold A_j=\bold D_j\bold T_j=(\bold S_j\bold R_j^{-1})\bold T_j$
- 不同动画短片的时间性插值：
  - 游戏动画机会不在整数帧上插值，故为了获得任意时间t的姿势，需要对来源姿势和参考姿势进行时间上LERP的插值
  - 同时需要输入的片段$S$和$R$持续时间相同，以保证全部时间内都有区别动画的定义
- 加法混合百分比：
  - 可通过LERP实现加法混合的百分比，即对初始的目标姿势和执行加法后的加法姿势进行LERP插值：
    - $\bold A_j\\=LERP(\bold T_j,\bold D_j\bold T_j,\beta)\\=(1-\beta)\bold T_j+\beta\bold D_j\bold T_j$
    - 注意插值需要使用SQT形式

##### 11.6.5.2 比较加法混合和分部混合

- 加法混合部署取代一组关节的动画，也不是对两个可能无关的姿势进行插值，而是将动作加入原本的动画内，动作可能横跨整个骨骼
- 区别动画含有如何改变角色的姿势来得到具体效果的信息，这些信息可以运用在其他动画上，同时效果比较自然

##### 11.6.5.3 加法混合的局限

- 可能导致骨骼中关节旋转过度
- 注意点：
  - 参考片段中，尽量减少髋关节的旋转
  - 参考片段中，肩及肘关节应该始终维持中性姿势，则将区别片段加入其他目标时，即可减轻手臂过度旋转的问题
  - 应为每个核心姿势创建新的区别动画

#### 11.6.6 加法混合的应用

##### 11.6.6.1 站姿变化

- 动画师对每个站姿创建1帧的区别动画，当这些单帧片段用加法混合混合至一个基本动画时，角色的站姿就会发生改变，但可以同时表现原本的动作

##### 11.6.6.2 移动噪声

- 现实中人运动时的每个脚步都不会完全一致，在人分心时更加明显
- 可以通过加法混合在完全重复的移动周期上叠加随机性、反应和分心的表现

##### 11.6.6.3 瞄准及注视

- 首先用动画令角色执行一些动作，如跑步，其中头部和武器都朝向前方
- 然后改变头部或武器方向至最右，并存储该帧或多帧的区别动画（最左、最上、最下同理）
- 则这四个区别动画就能用加法混合混合至原来的向前动画，产生向上、向下、向左、向右及之间的注视或瞄准动画

##### 11.6.6.4 时间轴的另类用途

- 动画片段的时间轴并不一定表示时间：
  - 如三帧动画表示三个瞄准姿势，第1帧向左瞄准，第2帧向前、第三帧向右
  - 要令角色向右瞄准，可将瞄准动画的局部时钟固定至第3帧
  - 为产生50%向前和向右的瞄准，只需将时钟拨至2.5帧

### 11.7 后期处理

- 动画后期处理：通过多个动画片段生成了骨骼的姿势，然后通过线性插值或加法混合成为一个姿势，在渲染角色前，通常还需要修改姿势

#### 11.7.1 程序式动画

- 程序式动画：任何运行时生成的动画，这些动画并不由动画工具导出的数据所驱动
  - 有时，手工制作的动画片段用于设置骨骼最初的姿势，然后程序动画会作为后期处理的形式修改此姿势

#### 11.7.2 逆运动学

- 逆运动学（IK, inverse kinematics）：假设一段动画片段为角色拾取地上的物体，在动画制作软件中效果好，但在实际游戏关卡中，由于地面并非完全平坦，有时角色的手会碰不到物体，有时又会穿过物体，在这种情况下，希望可以调整骨骼的最终姿势，令角色的手能完全与目标物体对齐
- 正向运动学$\leftrightarrow$反向运动学
  - 正向运动学：输入为一组局部姿势，输出是一个全局姿势，以及每个关节的蒙皮矩阵
  - 逆运动学：输入是某关节想要的全局姿势（称为末端受动器），要求出其他关节的局部姿势，使末端受动器能达到指定的位置
- 数学上，IK可归结为误差最小化问题，优化关节的末端与目标之间的距离

#### 11.7.3 布娃娃

- 当角色死亡或失去意识，其身体会变得瘫软，在此情况下，希望角色身体能与周边环境以真实的物理防晒互动，为此可使用布娃娃。
- 布娃娃是一组由物理模拟的刚体，每个刚体代表角色的半刚体身体部分，如下臂或上腿，这些刚体彼此受限于角色的关节位置，这些受限方式要设置成能产生自然的“无生气”的身体移动
- 刚体的位置和定向都是由物理系统计算的，然后用于驱动角色骨骼中某几个重要关节的位置和定向

### 11.8 压缩技术

- 动画数据会占用大量内存，每个关节姿势可能由10个浮点数通道（3平移4旋转3缩放），每个通道含4字节浮点数，以每秒30个样本的片段，即需要$4Byte\times10channel\times30sample/s=1200B/joint\cdot s$
- 原因：
  - 每个关节的姿势含有最多10个通道
  - 骨骼含有大量的关节
  - 角色的姿势通常采用高频率采样

#### 11.8.1 通道省略

- 省略无关的通道：
  - 多数角色不需要非统一缩放，因此三个缩放通道可缩减至单个统一缩放通道
  - 人形的骨骼通常是不能伸缩的，所以大部分关节的平移通道也可略去，只有根关节、面部关节以及一些颈关节需要保留
  - 四元数一直要保持归一，故只需存储3个分量
- 此外还可以对姿势的存储进行优化：若一些姿势在整个动画片段期间没有任何变化，则可以只存储该姿势位于$t=0$的第一个样本，再加1位标记表示该通道所有其他$t$值都是常数

- 通道省略可以大幅降低动画的尺寸：
  - 一个无平移、无缩放、含100个关节的骨骼只需303个通道，
  - 若100个关节都需要10个通道，则共需要1000个通道

#### 11.8.2 量化

- 缩减每通道的尺寸：
  - 浮点小数值正常会存储为32位IEEE格式，此格式提供23位的尾数精度，以及8位的指数
  - 但在动画中并不总是需要这么高的精确度，存储四元数时，可以保证其通道值的范围必为$[-1,1]$
  - 四元数可以仅用16位精度编码
- 将32位IEEE浮点数转换成n位整数表示法的运算称为量化，实际上分为两部分：
  - 编码：将原来的浮点小数值转换位量化后的整数表示法
  - 解码：把量化整数还原为原来浮点数的近似值（量化是有损压缩）
- 量化的过程：
  - 先将合法范围切割成N个同等大小的区间（N一般选用n位整数能表示的整数值范围）
  - 然后找出某浮点数值属于哪一个区间，并用该区间的整数索引值表示该值
  - 解码时，把整数索引值转换至浮点数格式，
  - 并用偏移及缩放把该值还原至原本的范围
- 四元数均为[0,1]范围内的值，故压缩较简单

- $[0,1]$范围浮点数编码至n位整数的代码：

  ```c++
  U32 CompressUnitFloatRL(F32 unitFloat, U32 nBits)
  {
      // 判断区间数量
      U32 nIntervals = 1u << nBits;
      
      // 将输入值从[0, 1]范围缩放至[0, nIntervals - 1]范围
      F32 scaled = unitFloat * (F32)(nIntervals - 1u);
      
      // 加上0.5f，再4舍5入至最近的区间中点，再将该值截尾，取得区间索引
      U32 rounded = (U32)(scaled + 0.5f);
      
      // 无效的输入保护
      if (rounded > nIntervals - 1u)
          rounded = nIntervals - 1u;
      return rounded;
  }
  
  F32 DecompressUnitFloatRL(U32 quantized, U32 nBits)
  {
      // 判断区间数量
      U32 nIntervals = 1u << nBits;
      
      // 解码时只需简单地将U32转成F32，并按区间大小缩放
      F32 intervalSize = 1.0f / (F32)(nIntervals - 1u);
      
     	F32 approxUnitFloat = (F32)quantized * intervalSize;
      return approxUnitFloat;
  }
  ```

- 处理任意位于$[min,max]$范围内的输入值的代码：

  ```c++
  U32 CompressFloatRL(F32 value, F32 min, F32 max, U32 mBits)
  {
      F32 unitFloat = (value - min) / (max - min);
      U32 quantized = CompressUnitFloatRL(unitFloat, nBits);
      return quantized;
  }
  
  F32 DecompressFloatRL(U32 quantized, F32 min, F32 max, U32 nBits)
  {
      F32 unitFloat = DecompressUnitFloatRL(quatized, nBits);
      F32 value = min + (unitFloat * (max - min));
      return value;
  }
  ```

- 封装为16位压缩：

  ```c++
  inline U16 CompressRotationChannel(F32 qx)
  {
      return (U16)CompressFloatRL(qx, -1.0f, 1.0f, 16u);
  }
  
  inline F32 DecompressRotationChannel(U16 qx)
  {
      return DecompressFloatRL((U32)qx, -1.0f, 1.0f, 16u);
  }
  ```

- 平移的缩放比旋转的稍困难，平移通道的范围在理论上是无界的。但是在实践中，角色的关节移动不会很远，故可设定一个合理的移动范围，若出现超越合法范围时的动画即报错

  - 但游戏的内置电影在世界空间制作动画时，角色的根关节的平移值可能很大
  - 为解决此问题，可以以动画或关节为单位，针对每个片段实际的最大平移值，选择合法的平移范围；同时将数据范围存储在压缩片段数据中

#### 11.8.3 采样频率及键省略

- 解决高频率采样的方法：
  - 降低整体的采样率：
    - 有些动画以每秒15帧导出，效果还可以，这么做能使动画数据大小降为一半
    - 省略一些样本：若片段在某个时间区间内，通道数据变化大约呈线性变化，则可以省略此区间内除首尾外的所有样本，在运行时使用线性插值还原删掉了的样本

#### 11.8.4 基于曲线的压缩

- 不使用等距的姿势样本序列存储动画，而是用一组n阶非均匀、非有理B样条描述关节S、Q、T通道随时间变化的路径
  - 使用B样条的好处是可用少量数据点为高曲率的通道编码

#### 11.8.5 选择性载入及串流

- 多数游戏不需要将所有动画同时置于内存，
  - 有些片段只应用在某角色职业，若某关卡中未遇到该职业的角色，则不需要载入这些片段
  - 有些片段在游戏中只会使用一次，这些片段可以在需要播放之前再载入或串流，播放结束后就从内存中释放
- 多数游戏会在游戏开始时载入一组核心动画片段，并一直把他们保留在内存中，其他动画则是按需载入的
  - 有的游戏引擎按逐个动画片段载入
  - 有的游戏引擎会把动画片段打包成逻辑组，并以此为单位载入和卸载

### 11.9 动画系统架构

- 游戏动画理论的软件架构，3个明确的软件层 ：
  - 动画管道：
    - 对游戏中含有动画的角色/物体，动画管道为其取得一个或多个动画片段及对应的混合因子为输入，把这些片段混合后产生一个局部骨骼姿势作为输出，
    - 同时为骨骼计算一个全局姿势，以及生成蒙皮矩阵调色板共渲染引擎使用
    - 动画管道通常会提供后期处理钩子，以便在生成全局姿势及蒙板矩阵前可以修改局部姿势
  - 动作状态机（ASM）：
    - 游戏角色的动作通常建模为有限状态机，此状态机常称为动作状态机
    - ASM子系统位于动画管道之上，并提供以状态驱动的动画接口供所有高层游戏代码使用
    - ASM确保角色能从一个状态平滑地过渡至另一状态
    - 使用状态层：多个独立状态机控制单个角色，以实现允许角色身体的不同部分同时做不同、独立的事情
  - 动画控制器：
    - 许多游戏引擎中，玩家与非玩家角色的行为最终是由动画控制器所组成的高级系统控制的
    - 每个控制器是特别为管理某个角色行为模式而设的（如一个控制器用于角色在开放空间移动及战斗中处理其行为）
- 某些引擎会以不同的方式分割上述软件层，或将软件层合并

### 11.10 动画管道

- 动画管道：构成一个把输入（动画片段/混合设置）变换成输出（局部、全局姿势及渲染用的矩阵调色板）的管道，各个阶段如下：

  - 片段解压及姿势提取：

    - 数据被解压，并提取所需时间索引的静态姿势；
    - 输出为每个输入片段的一个局部骨骼姿势，此姿势可能包含全身的姿势，也可能仅包含部分关节的信息（分部姿势），或用作加法混合的区别姿势

  - 姿势混合：

    - 通过全身LERP混合、分部LERP混合，及/或加法混合，把输入姿势结合在一起
    - 输出为一个对应骨骼中所有关节的局部姿势，只有当需要混合超过一个动画片段时才执行本阶段，否则直接使用阶段1的输出

  - 全局姿势生成：

    - 遍历骨骼层次结构，把局部关节串接以产生骨骼的全局姿势

  - 后期处理：

    - 可选阶段
    - 使输出最终姿势之前，有机会修改骨骼的局部及/或全局姿势
    - 用于逆运动学、布娃娃物理、以及其他形式的程序动画

  - 重新计算全局姿势：

    - 许多种类的后期处理都需要全局姿势作为输入，但只输出局部姿势，执行这类后期处理步骤后，需要从修改后的局部姿势重新计算全局姿势

  - 生成矩阵调色板：

    - 生成最终全局姿势后，本阶段把每个关节的全局姿势矩阵乘以对应的逆绑定姿势矩阵乘以对应的逆绑定姿势矩阵
    - 输出为共渲染引擎所用的蒙皮矩阵调色板

    ![image-20210609161957081](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210609161957081.png)

#### 11.10.1 数据结构

##### 11.10.1.1 共享资源数据

- 共享资源数据$\leftrightarrow$每实体状态信息：

  - 游戏中每个单独的角色和物体都有其每实体状态信息
  - 但相同类型的角色或物体都会共享一组资源数据

- 共享资源数据包含的内容：

  - 骨骼：描述关节层次结构及其绑定姿势
  - 蒙皮网络：一个或多个可蒙皮至单个骨骼的网格，蒙皮网格中的每个顶点都包含一个或多个关节索引，加上那些关节对该顶点的影响力
  - 动画片段：为每个角色骨骼制作的数百/上千个动画片段，这些片段可以是全身片段、分部片段、或用于加法混合的区别片段

- 共享数据资源的UML图：

  ![image-20210609163504012](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210609163504012.png)

  - 共享数据资源中包含
    - 一个骨骼
      - 多个关节
      - 一个或多个蒙皮网格
        - 多个顶点
      - 一个或多个动画片段
        - 多个骨骼姿势
          - 多个SQT变换

- 游戏设计师通常会尽量减少骨骼数目，因为每个新骨骼需要一组全新的动画片段，为了令游戏看起来有更多的不同类型角色，通常会尽量制作多个绑定至单个骨骼的网格，使所有角色能共享一组动画

- 高品质实时骨骼重定目标技术使得为一个骨骼制作的动画可用于另一骨骼，

  - 若两个骨骼在形态上相同，则重定目标为简单的关节索引重新映射、
  - 若两个骨骼并不完全匹配，则重定目标更为复杂
    - 一种实现是定义重定目标姿势的特别姿势，用于捕捉来源骨骼和目标骨骼的绑定姿势的本质区别，令运行时重定目标系统能调整来源姿势，以自然地应用在目标角色上

##### 11.10.1.2 每实例数据

- 游戏中每个角色种类地多个实例可在同屏上出现，某个角色种类地每个实例都需要其私有数据结构以记录当前播放中的动画片段、片段混合方式，以及当前骨骼姿势等
- 引擎会记录的信息：
  - 片段状态：每个播放片段中都需要维护的信息
    - 局部时钟：描述其局部时间线上的一点，该时间点用于提取当前姿势，一些游戏引擎中，局部时钟由全局起始时间所替代
    - 播放速率：片段可以任何速率播放，播放速率表示为$R$
  - 混合规格：
    - 描述哪些动画片段正在播放，以及这些片段是如何混合在一起的，每个片段通过混合权重设置它对最终姿势的影响
    - 主要有两种方式描述片段混合的方式，统一加权法和混合树，当使用树状方式时，混合树的结构会被视为共享资源，其中的混合权重则存储为每实例状态数据
  - 分部骨骼关节权重：
    - 若应用分部骨骼混合，则每个节点对最终姿势的影响力会存储为一组关节权重，一些动画引擎的关节权重是二元的，关节权重只能设为0或1；另一些动画引擎中，可设置权重为0至1
  - 局部姿势
    - 局部姿势是一个SQT数组的数据结构，其中每个SQT对应一个关节，存储成相对于父关节的骨骼最终姿势
    - 此数组也可能用于存储中间姿势，以作为管道中后期处理阶段的输入及输出
  - 全局姿势
    - 可以是SQT，$4\times4,4\times3$的数组，其中每个元素对应一个关节，存储模型空间或世界空间的最终骨骼姿势，全局姿势可能会用作后期处理的输入
  - 矩阵调色板
    - 矩阵调色板是$4\times4or4\times3$矩阵，其中每个元素对应一个关节，存储蒙皮矩阵，供渲染引擎之用

#### 11.10.2 扁平的加权平均混合表示法

- 游戏引擎支持某种形式的动画混合，这意味着在某一指定时间，多个动画片段能对角色骨骼的最终姿势产生影响，如何描述混合作用中的片段，最简单的方法即为加权平均

- 此方法中，每个动画片段对应一个混合权重，此权重描述对该片段的角色最终姿势的影响力。

- 引擎维护一个作用中的动画片段的扁平列表，为计算骨骼姿势，

  - 首先从N个作用片段中，对每个片段在恰当的时间索引上提取姿势

  - 再对骨骼中的每个关节，对从N个作用动画提取到的平移矢量、旋转四元数、缩放因子计算N点加权平均数，以此产生骨骼的最终姿势：

  - N个矢量$\bold v_i$的集合的加权平均算式如下：

    - $\displaystyle \bold v_{avg}=\frac{\sum_{i=0}^{N-1}w_i\bold v_i}{\sum_{i=0}^{N-1}w_i}$

    若已归一化则：

  - $\displaystyle \bold v_{avg}=\sum_{i=0}^{N-1}w_i\bold v_i$

  - 在$N=2$的情况下，该式退化为两矢量的线性插值

  - 对四元数，将其视为含4个分量的矢量即可

#### 11.10.3 混合树

- 有些动画引擎并不是以扁平加权平均描述混合方式的，而使用混合操作树
- 该树的内节点是运算符，而叶节点则是那些运算符的输入（内节点：非终止符，外节点：终止符）

##### 11.10.3.1 二元LERP混合

- 二元线性插值混合从两个输入姿势混合成一个输出姿势，混合权重$beta$控制第2个输入姿势显示于输出姿势的百分比，而$1-\beta$表示第1个姿势的百分比，此混合可以表示为二叉表达式树

  ![image-20210609193851132](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210609193851132.png)

##### 11.10.3.2 泛化一维LERP混合

- 这种混合通过混合因子$b$指定在轴上位置所需的混合，只需使用最接近b的两个输入片段作为二元混合的输入，并使用归一化公式计算$\beta$值，表达为n个输入的运算符

  ![image-20210609194241563](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210609194241563.png)

##### 11.10.3.3 简单二维LERP混合

- 简单二维LERP混合使用两个简单一维LERP的LERP混合表达：

  ![image-20210609194352275](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210609194352275.png)

##### 11.10.3.4 三角LERP混合

- 用三叉树表达树，再提供$\alpha,\beta,1-\alpha-\beta$作为输入：

  ![image-20210609194643730](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210609194643730.png)

##### 11.10.3.5 泛化三角LERP混合

- 通过Delaunay三角剖分找出包含点$\bold b$的三角形，再将该点转换为重心坐标$\alpha,\beta,1-\alpha-\beta$，并使用这些坐标作为三元混合节点的混合权重

  ![image-20210609194850337](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210609194850337.png)

##### 11.10.3.6 加法混合

- 表达为二元操作，混合权重$\beta$表明区别动画在输出中的程度，$\beta=0$即完全不影响输出

  ![image-20210609195050025](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210609195050025.png)

- 加法混合片段的输入次序是不可更换的，两个输入之一是正常的骨骼姿势，而另一个则为区别姿势，区别姿势只可施于正常姿势，加法混合的结果是另一个正常姿势，

  - 这意味着加法混合的区别片段输入必须为一个叶节点
  - 而正常输入则可以是叶节点或内节点

- 若要将多个区别动画施于角色，则必须施于层叠式的二叉树：

  ![image-20210609195325935](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210609195325935.png)

#### 11.10.4 淡入/淡出架构

##### 11.10.4.1 扁平加权平均的淡入/淡出

##### 11.10.4.2 表达式树的淡入/淡出

#### 11.10.5 动画管道的优化

### 11.11 动作状态机

#### 11.11.1 动画状态

### 11.12 动画控制器























