[toc]

## 11 动画系统

- 动画系统为角色赋予自然的动作

### 11.1 角色动画的类型

#### 11.1.1 赛璐璐动画

- 所有游戏动画技术的前身都是传统动画或手绘动画，这些动画的动感由连续快速显示一系列静止图片所产生，这些图片称为帧，可将三维渲染想象为传统动画的电子形式，把一系列静止的全屏影像不断地向观众展示，以产生动感
- 赛璐璐动画是传统动画的一个种类，将一连串的透明塑料片放置于固定的手绘背景，即可产生动感，而无须不断重复绘制静态的背景
- 赛璐璐动画的电子版本称为精灵动画，
  - 精灵：一张小位图，叠在全屏的背景影像之上而不会扰乱背景，通常由专门的图形硬件绘制
  - 是二维游戏时代最主要的技术
  - 循环动画：一组帧通常被设计成重复播放也流畅的形式，此组动画以现在的说法可称为一个跑步周期，角色通常有多组循环动画周期，包括闲置周期、步行周期及跑步周期
- 如今精灵动画仍被用于低分辨率或远距离的物体上：
  - 物体是面向摄像机的四边形，每个四边形贴上一连串纹理位图，以产生动感

#### 11.1.2 刚性层阶式动画

- 角色由一堆刚性部分建模而成，人形角色通常会拆分成
  - 骨盆
  - 躯干
  - 上臂
  - 下臂
  - 大腿
  - 小腿
  - 手部
  - 脚步
  - 头部
- 这些刚性部分以层阶的形式彼此约束，类似于哺乳类动物以关节连接骨骼，这样能使角色自然地移动
- 一般的层阶会以骨盆为根，躯干和大腿是其直接子嗣，其他部分如下连接：
  - 骨盆 Pelvis
    - 躯干 Torso
      - 右上臂 UpperRightArm
        - 右前臂 LowerRightArm
          - 右手 RightHand
      - 左上臂 UpperLeftArm
        - 左前臂 LowerLeftArm
          - 左手 LeftHand
      - 头 Head
    - 右大腿 UpperRightLeg
      - 右小腿 LowerRightLeg
        - 右脚 RightFoot
    - 左大腿UpperLeftLeg
      - 左小腿 LowerLeftLeg
        - 左脚 LeftFoot

- 刚性层阶技术的问题：
  - 角色的身体会在关节位置产生碍眼的“裂缝”
    - 对于确实由刚性部件组成的机器人及机械，刚性层阶式动画效果不错
    - 但对有血有肉的人物，仔细看会发现问题

#### 11.1.3 每顶点动画及变形目标

- 刚性层阶式动画由于各部分为刚性的，往往显得不自然，真正希望实现的是能移动每个顶点，使三角形拉伸以产生更自然生动的动作
- 每顶点动画：
  - 动画师为网格的顶点添加动画，这些动作数据导出游戏引擎后，就能告诉引擎在运行时如何移动顶点，此技术能产生任何能想象到的网格变形
  - 但这是一种数据密集的技术，因为每个顶点随时间改变的动作信息都需要存储，因此在实时游戏中很少使用
- 变种：变形目标动画
  - 由动画师移动网格的顶点，但仅制作相对少量的固定极端姿势，在运行时将两个或以上的姿势混合，就能生成动画
  - 每个顶点的位置是简单地把每个极端姿势的位置进行线性插值而得的
  - 变形目标技术通常用于面部动画，因为人脸具有非常复杂的解剖结构，其动作大约由50组肌肉所驱动，动画师能使用变形目标动画去完全控制脸上的每个顶点，制作出细微及极端的移动，模拟面部肌肉组织
  - 由于计算能力的不断提升，有些工作室使用具有数百个关节的面部索具，取代变形目标；另一些工作室合并两种技术，使用关节锁具完成基本姿势，再利用变形目标做细节调整

#### 11.1.4 蒙皮动画

- 蒙皮动画中
  - 与刚性层阶动画类似，骨骼由刚性的“骨头”构建而成，但这些刚性部件不会渲染显示，始终被隐藏
  - 称为皮肤的光滑三角形网格会绑定于骨骼上，其顶点跟着关节的移动，蒙皮上的每个顶点可按权值绑定至多个关节，当关节移动时，蒙皮可以自然的拉伸

- 优点：
  - 允许组成网格的三角形做出变形
  - 高效性能、内存使用量小
  - 可以产生相当接近真实的皮肤和衣着的移动

#### 11.1.5 把动画方法视为数据压缩技术

- 可把最有弹性的动画系统想象成动画师能控制物体表面上无穷多的点，
  - 但此方法制作动画，会导致包含无穷多的数据
  - 理想的简化版本是控制三角形网格的顶点
    - 则实际上是将描述动画的信息加以压缩，限制只能移动顶点
    - 变形目标也可被想象为更进一步的压缩，其压缩方法是在系统中加入更多的约束：
      - 顶点只能在一组固定数目的预定义顶点位置间的线性路径中移动，
      - 骨骼动画是另一种通过加入约束来压缩顶点动画的方法，大量的顶点只能跟随相对少量的骨骼关节移动
- 权衡各种动画技术时，可将其当作压缩方法来考虑
  - 选择动画技术的目标：
    - 提供最佳压缩，但又不会产生不能接受的视觉瑕疵
  - 骨骼动画能提供最佳的压缩，因为每个关节的移动会扩大至多个顶点的移动
    - 角色的四肢大部分行为像刚体，故能有效地使用骨骼移动
    - 但面部的动作更加复杂，每个顶点的移动更加独立，若要使用骨骼的方式制作有说服力的动画，需要的关节就会接近网格的顶点数量，因而降低了骨骼动画作为压缩方法的效能，因此面部动画更多使用变形目标

### 11.2 骨骼

- 骨骼由刚性的关节层阶结构所组成
  - 骨头是关节间的空位

#### 11.2.1 骨骼层阶结构

- 骨骼关节形成层阶结构，也称树结构，蒙皮动画所用的关节层阶，通常和刚性层阶相同，人性角色的关节层阶可能如下：

  ![image-20210607112811038](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210607112811038.png)

- 通常为每个关节赋予$0\to(N-1)$的索引，由于每个关节有且有一个关节点，所以只要在每个关节存储其父关节的索引即可；根节点无父关节，其父索引通常被设为无效值，如$-1$

#### 11.2.2 在内存中表示骨骼

- 骨骼通常由一个细小的顶层数据结构表示，该结构有关节数组，关节的存储次序通常会保证每个子关节都位于其父关节之后，数组中的首个关节总是骨骼的根关节

- 动画数据结构中，使用关节索引引用关节

  - 如子关节通常以索引引用其父关节，
  - 在蒙皮三角形网络中，每个顶点使用索引引用其绑定关节
  - 优点：
    - 存储空间上，如果每个关节索引使用8位整数，则使用空间较小
    - 查找引用关节的时间上，索引可直接存取数组中所需的关节，效率高

- 关节的数据结构通常包含以下信息：

  - 关节名字：字符串或32位字符串散列标识符
  - 骨骼中其关节的索引
  - 关节的绑定姿势的逆变换
    - 绑定姿势：蒙皮网络顶点被绑定至骨骼时，关节的位置、定向及缩放

- 典型的骨骼数据结构：

  ```c++
  struct Joint
  {
      Matrix4x3 	m_invBindPose; 	// 绑定姿势的逆变换
      const char* m_name;			// 人可读的关节名
      U8 			m_iParent;		// 父索引，0xFF代表根节点
  };
  struct Skeleton
  {
      U32 		m_jointCount;	// 关节数目
      Joint* 		m_aJoint;		// 关节数组
  }
  ```

### 11.3 姿势

- 通过把角色身体摆出一连串离散、静止的姿势，并以通常每秒30或60个姿势的速度显示这些姿势（为相邻的姿势插值，而非直接显示），即可令角色产生动感
- 在骨骼动画中，骨骼的姿势直接控制网格顶点，将关节任意旋转、平移及缩放，就能为骨骼摆出各种姿势，
  - 一个关节的姿势被定义为关节相对某参考系的位置、定向和缩放
  - 关节的姿势通常以$4\times4$或$4\times3$矩阵表示，或表示为SQT数据结构
- 骨骼的姿势是所有关节姿势的集合，并通常简单地以SQT数组表示

#### 11.3.1 绑定姿势

- 三维网格绑定至骨骼之前的姿势，又称参考姿势、放松姿势、T姿势（T-pose）

  - 此姿势中的四肢远离身体，容易将顶点绑定至关节

  ![image-20210607140941647](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210607140941647.png)

#### 11.3.2 局部姿势

- 局部姿势：最常见的关节姿势是相对于父关节来指定的，相对父关节的姿势能令关节自然地移动，称为局部姿势

- 局部姿势存储为SQT格式

- 数学上，关节姿势表示为仿射变换，第$j$个关节表示为$4\times4$仿射变换矩阵$\bold P_j$

  $\bold P_j=\left[\begin{array}{}\bold S_j\bold R_j&0\\\bold T_j&1\end{array}\right]$

  - $\bold S_j$：对角缩放矩阵
  - $\bold R_j$：旋转矩阵
  - $\bold T_j$：平移矢量

- 整个骨骼的姿势表示为所有关节姿势的集合：

  $\displaystyle \bold P^{skel}=\{\bold P_j|_{j=0}^{N-1}\}$

##### 11.3.2.1 关节缩放

- 允许的缩放类型：
  - 某些引擎不允许关节缩放，则忽略$\bold S_j$，将其视为单位矩阵
  - 某些引擎只允许统一缩放，则$\bold S_j$视为标量$s_j$
  - 某些引擎支持非统一缩放，则缩放可紧凑地表示为3元素矢量$\bold s_j=\begin{array}{}[s_{jx}&s_{jy}&s_{jz}]\end{array}$
- 限制缩放的好处：
  - 减少内存开销
  - 限制使用统一缩放，可以避免包围球不会变换为椭球体，以简化按每关节计算的平截头体剔除及碰撞测试

##### 11.3.2.2 在内存中表示关节姿势

- 关节姿势通常表示为SQT格式：

  ```c++
  struct JointPose
  {
  	Quaternion 	m_rot;		// Q
      Vector3 	m_trans;	// T
      F32			m_scale;	// S,统一缩放
  }
  ```

  或

  ```c++
  struct JointPose
  {
  	Quaternion 	m_rot;		// Q
      Vector3 	m_trans;	// T
      Vector3		m_scale;	// S,非统一缩放
  }
  ```

- 整个骨骼的局部姿势表示为：

  ```c++
  struct SkeletonPose
  {
  	Skeleton*	m_pSkeleton;	// 骨骼 + 关节数量
      JointPose* 	m_aLocalPose;	// 多个局部关节姿势
  }
  ```

  - 其中， m_aLocalPose数组是动态分配的，该数组刚好可容纳匹配骨骼内关节数目的JointPose

##### 11.3.2.3 把关节姿势当作基的变更

- 局部关节姿势是相对其直属的父关节指定的，任何仿射变换都可想象为把点或矢量从一个坐标系变换至另一个坐标系，当把关节姿势变换$\bold P_j$施于以关节$j$坐标系表示的点或矢量时，其变换结果是以父空间表示的该点的矢量
- 使用下标表示变换的方向：
  - 关节姿势将点和矢量从子关节的空间（C）变换至父关节的空间（P），因此将此变换写为$(\bold P_{C\to P})_j$
  - 另一种方式是引入一个函数$p(j)$，它会回传关节$j$的父索引，则可记关节$j$的局部姿势为$\bold P_{j\to p(j)}$
- 当要以相反的方向变换点及矢量（父关节的空间变换至子关节的空间），此变换就是局部关节姿势的逆变换：
  - $\bold P_{p(j)\to j}=(\bold P_{j\to p(j)})^{-1}$

#### 11.3.3 全局姿势

- 全局姿势：将关节姿势表示为模型空间或世界空间

- 数学上，某关节的模型空间姿势$(j\to M)$可通过从该关节遍历至根节点时，在每个关节乘上其局部姿势$(j\to p(j))$算出，如：

  ![image-20210607151231907](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210607151231907.png)

  - 关节$J_2$的模型空间姿势可表示为：
    - $\bold P_{2\to M}=\bold P_{2\to 1}\bold P_{1\to 0}\bold P_{0\to M}$
  - 关节$J_5$的模型空间姿势可表示为：
    - $\bold P_{5\to M}=\bold P_{5\to 4}\bold P_{4\to 3}\bold P_{3\to 0}\bold P_{0\to M}$
  - 任意关节$j$的全局姿势：
    - $\displaystyle \bold P_{5\to M}=\prod_{i=j}^0P_{i\to p(i)}$
    - 每次乘法迭代可理解为$i$变成$p(i)$即i的父关节，且$p(0)\equiv M$

##### 11.3.3.1 在内存中表示全局姿势

- 扩展SkeletonPose，以包含全局姿势

  ```c++
  struct SkeletonPose
  {
  	Skeleton*	m_pSkeleton;	// 骨骼 + 关节数量
      JointPose* 	m_aLocalPose;	// 多个局部关节姿势
      Matrix44*	m_aGlobalPose;	// 多个全局关节姿势
  }
  ```

  - 其中m_aGlobalPose数组是基于骨骼中的关节数目动态分配的

### 11.4 动画片段

- 比较动画电影与游戏中的动画：
  - 动画电影：
    - 整个场景以一串很长的、连续的帧来产生动画
  - 游戏：
    - 游戏角色的移动必须被拆分为大量小粒度的动作，被称为动画片段，有时也简称为动画
    - 每个片段都能令角色表现一个有明确界定的动作。
      - 有些片段被设计成循环形式，如跑步；有的则只会播放一次，如跌倒
      - 有些片段影响角色全身，如跳跃；有的则只影响身体的一部分，如挥手
    - 一个角色的动作一般会被拆分为上千个片段
    - 例外：当角色进入游戏中的非互动的部分（游戏内置电影IGC、非交互连续镜头NIS、全动视频FMV）时，这些非互动序列制作方法类似动画电影
      - IGC、NIS：游戏引擎渲染的非互动序列
      - FMV：预先渲染至MP4、WMV或其他的视频文件类型，然后在运行时由引擎内的全屏电影播放器播放
    - 非互动序列的变种是半互动序列：快速反应事件QTE，QTE内玩家必须在非互动序列中的正确时间按键，才能看到成功的动画并继续，否则播放失败动画

#### 11.4.1 局部时间线

- 每个动画片段都有一条局部时间线，该时间线使用自变量$t$表示，片段开始时$t=0$，结束时$t=T$，$T$为片段持续时间

- 变量$t$的每个值称为时间索引

  ![image-20210607154337481](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210607154337481.png)

##### 11.4.1.1 姿势插值及连续时间

- 帧展示的频率并不一定等于动画师制作的姿势的播放频率

  - 动画师会在片段中指定的时间点设定一些重要的姿势，称为关键姿势或关键帧

  - 计算机会采用线性或基于曲线的插值计算中间的姿势

    ![image-20210607154727501](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210607154727501.png)

  - 由于动画引擎能够对姿势插值，因此可以在片段中的任何时间采样，而不一定要在整数帧索引上采样，故动画的时间线是连续的，即$t$为浮点数 

- 动画电影的帧率为定值，故只会在整数帧上采样；而实时游戏中，游戏的帧率会受CPU/GPU的负载的影响，使角色动作与原本制作动画的速率不同，故几乎不会在整数帧索引上采样

- 游戏动画的时间是连续的，且可改变比例的

##### 11.4.1.2 时间单位

- 时间变量$t$为浮点数，最好用秒作为时间单位
- 若定义了帧的持续时间，则时间也可以使用帧作为度量单位，典型的帧持续时间为$1/30s$或$1/60s$
- 避免将时间定义为整数，时间应为浮点数、定点数或非常小的子帧时间间隔的整数
- 时间的度量应当具有足够的分辨率，以计算帧之间的结果或改变动画播放速率

##### 11.4.1.3 比较帧与采样

- 每秒30帧，包含31个采样
- 以帧表示$1/30s$或$1/60s$的持续时间
- 采样表示其中的数据点

##### 11.4.1.4 帧、采样及循环片段

- 循环：把动画片段设计为不断重复播放
- 为保证片段无缝衔接，最后一个采样与第一个采样相同，因此循环片段的最后一个采样是冗余的，故许多游戏引擎会略去最后一个采样
- 非循环动画：
  - N帧，N+1个采样
- 循环动画：
  - N帧，N个采样

##### 11.4.1.5 归一化时间（相位）

- 归一化时间u，$u=0$代表动画的开始，$u=1$代表动画的结束，不管动画的持续时间$T$为多长，有时归一化时间被称相位
- 当同步两个或以上的动画片段，且其持续时间不同时，可使用归一化时间确保两个动画的播放速度匹配：
  - 将两段动画的归一化起始时间匹配，再使用相同的归一化速率推进，使两片段保持同步
  - 较绝对时间索引：更易实现，且不易出错

#### 11.4.2 全局时间线

- 每个角色都有一个全局时间线，时钟在角色诞生于游戏世界或关卡、游戏开始时启动

- 播放动画可以视为将片段的局部时间映射至角色的全局时间，记为$\tau$：

  ![image-20210607161420238](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210607161420238.png)

- 播放循环动画即将片段复制无限次，并前后相连至全局时间线；也可将动画循环播放有限次，即复制片段有限次首尾相接置于全局时间线

- 在片段中调整时间比例，即可倍速播放片段

  - 实现：将片段置于全局时间线上时缩放其比例，即播放速率，使用变量$R$表示
  - 若2倍速播放，则$R=2$，在将局部时间线放置在全局时间线上时，将局部时间线压缩为正常长度的一半
  - 判断倒转，即$R=-1$

- 局部时间线至全局时间线的映射方法：

  - 将动画映射至全局时间线需要的信息：
    - 全局起始时间$\tau_{start}$
    - 播放速率$R$
    - 持续时间$T$
    - 循环次数$N$
  - 基于以上信息，构建的局部时间线至全局时间线及反向的映射为：
    - $\tau =\tau_{start} + \frac{1}{R}t$
    - $t=R(\tau-\tau_{start})$
  - 从全局时间映射至局部时间后要保证时间的合法性：
    - 若动画非循环（$N=1$）：
      - 在使用$t$为片段采样一个姿势之前，需要先将$t$剪裁至合法范围$[0,T]$
    - 若动画无限循环（$N=\infty$）：
      - 可以用$t$对持续时间$T$取模，以得到合法范围的时间
    - 若动画有限循环（$0<N <\infty$）
      - 则需先将$t$剪裁至$[0,NT]$的范围，再将结果对$T$取模，得到合法范围的时间

- 多数游戏引擎直接使用局部动画时间线，而不使用全局时间线，但使用全局时间线会使得同步动画变得更加直观

#### 11.4.3 比较局部和全局时钟

- 记录时间索引的方法：
  - 局部时钟：
    - 每个片段都有其局部时钟，时钟通常用秒/帧/归一化时间为单位，以浮点小数形式存储
    - 片段开始播放时，局部时间$t$被设置为0
    - 随时间推移，每个片段各自的局部时钟向前推进
    - 若片段有非正常播放速率，则局部时钟再推进时以$R$缩放
  - 全局时钟：
    - 角色含有全局时钟，通常以秒为单位，每个片段记录其开始播放时的全局时间$\tau_{start}$，片段的局部时钟由上述公式计算，而非直接存储于片段之中
- 比较：
  - 局部时钟：
    - 简单，动画系统的显然选择
  - 全局时钟：
    - 适用于同步动画，无论是单个角色本身的同步还是场景中多个角色的同步

##### 11.4.3.1 用局部时钟同步动画

- 同步两个或以上的片段，需要在完全相同的游戏时间对其播放，但若播放命令来自多个不同子系统，就会产生一定的延迟：
  - 如玩家出拳的动画在玩家子系统内播放，NPC受击动画由AI子系统播放，若游戏循环内AI子系统的代码先于玩家子系统代码执行，则玩家出拳和NPC的反应就会存在一帧的延迟，反之亦然
- 若两子系统之前的通信使用消息传送（事件）系统，则还会有额外的延迟、

##### 11.4.3.2 用全局时钟同步动画

- 全局时钟方法有助于解决同步问题，所有片段的时间线都有相同的原点，在多个动画中，若其全局的开始时间在数值上相同，则这些片段在开始时就是完全同步的。若片段的播放速率相同，则片段一直同步
- 全局同步需要确保两个角色的全局时间相互匹配：这可根据两个角色的全局时钟只差，调整两个全局开始时间；或令游戏中所有角色共享同一个时钟

#### 11.4.4 简单动画的数据格式

- 动画数据一般是离散地以每秒30个或60个骨骼姿势地的速率采样而得，一个采样由骨骼中每个关节的完整姿势组成。这些关节姿势通常存储为SQT格式，对每个关节$j$：

  - 缩放：标量$S_j$或三维矢量$\bold S_j$
  - 旋转：四元数$Q_j$
  - 平移：三维矢量$\bold T_j$

- 即一个动画由每关节至多10个通道（即SQT的10个分量）组成

- 动画片段的表示：

  ```c++
  struct JointPose
  {
  	Quaternion 			m_rot;			// Q
      Vector3 			m_trans;		// T
      Vector3				m_scale;		// S,非统一缩放
  }
  
  struct Joint
  {
      Matrix4x3 			m_invBindPose; 	// 绑定姿势的逆变换
      const char* 		m_name;			// 人可读的关节名
      U8 					m_iParent;		// 父索引，0xFF代表根节点
  };
  struct Skeleton
  {
      U32 				m_jointCount;	// 关节数目
      Joint* 				m_aJoint;		// 关节数组
  }
  
  // 一次采样 
  struct AnimationSample
  {
      JointPose* 			m_aJointPose;	// 关节姿势数组
  }
  
  // 完整动画
  struct AnimationClip
  {
      Skeleton* 			m_pSkeleton;
      F32					m_framesPerSecond;
      U32					m_frameCount;
      AnimationSample*	m_aSamples;		// 采样数组
      bool 				m_isLooping;
  }
  ```

- 每个动画片段都是为特点骨骼设计的，通常不会用于其他骨骼，如上述例子中AnimationClip数据结构中含有其骨骼的引用m_pSkeleton（真实的引擎中可能使用唯一的骨骼表示符，此时引擎需提供快速、方便的方法以标识符查找骨骼）

- m_aJointPose的数组长度已假定和骨骼的关节数相同

- m_aSamples数组的采样数目由帧数及该片段是否用于循环决定的，如前所述

  - 非循环动画的采样数目为m_frameCount + 1
  - 循环动画的采样数目为m_frameCount

- 真实引擎中，还会对动画数据进行压缩，以节省内存

##### 11.4.4.1 动画重定目标

- 尽管一个动画通常仅兼容特定骨骼，但若多个骨骼近似（含有不影响主要层次结构的子关节），则也可应用于其余骨骼，此时需要引擎在对于其余骨骼播放动画时忽略动画中未能与骨骼匹配的关节
- 更先进的技术：将为一个骨骼设计的动画重定目标至不同骨骼

#### 11.4.5 连续的通道函数

- 动画片段的采样用于定义随时间改变的连续函数（1个自变量t，10个标量因变量）

- 但在实践中许多游戏引擎只会在采样间进行线性插值，使用元连续函数的分段线性逼近

  ![image-20210607173910994](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210607173910994.png)

#### 11.4.6 元通道

- 在动画的基础10通道外增加额外的元通道数据，以存储额外的信息，将游戏专用的信息编码，同时和动画同步，且无需将信息以骨骼姿势存储

- 常见的元通道：

  - 事件触发器

    - 当动画的局部时间经过触发器时，触发器的事件就会交送游戏引擎，引擎按需处理这些事件

    ![image-20210607174544587](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210607174544587.png)

  - 定位器：

    - 可以和骨骼关节一起设置动画，由于定位器和关节一样为仿射变换，故这些特殊关节可用于记录游戏中任何物体的位置及定向
    - 定位器的常见用法是在动画中设置摄像机的位置及角度，可将摄像机绑定至某个定位器，然后与角色的关节一起设置动画，将摄像机的定位器导出后，就能在游戏中播放动画时移动摄像机，摄像机的视野及其他摄像机属性也可设置动画，其数据存储在一个或以上的浮点通道中

  - 其余非关节动画通道的例子：

    - 纹理坐标滚动
    - 纹理动画
    - 含动画的材质参数
    - 含动画的光源半径
    - 其他随时间改变，并以某种形式和动画同步的参数

### 11.5 蒙皮及生成矩阵调色板

- 蒙皮：将三维网格顶点联系至骨骼

#### 11.5.1 每顶点的蒙皮信息

- 蒙皮用的网格通过其顶点系上骨骼，每个顶点可以绑定（bing）至一个或多个关节：

  - 绑定至一个关节：完全跟随该关节移动
  - 绑定至多个关节：逐一绑定至每个关节后位置的加权平均

- 将网格蒙皮至骨骼，建模师需为每个顶点提供的信息：

  - 顶点要绑定到的（一个或多个）关节索引
  - 每个绑定的关节的权重（各个顶点的权值和为1）

- 游戏引擎通常限制每个顶点能绑定的关节数目，典型数量为每个顶点4个关节：

  - 4个8位关节索引可被包裹为一个32位字
  - 每顶点使用2个、3个及4个关节的质量差异容易区分，但超过4个关节，则多数人很难区分

- 由于关节权值的和为1，故最后一个权重可以略去，典型的蒙皮顶点数据结构如下：

  ```c++
  struct SkinnedVertex
  {
      float	m_position[3];		// 顶点坐标
      float	m_normal[3];		// 法线向量
      float	m_u, m_v;			// 纹理坐标
      U8		m_jointIndex[4];	// 关节索引
      float 	m_jointWeight[3];	// 关节权重，略去最后一个
  }
  ```

#### 11.5.2 蒙皮涉及的数学知识

- 蒙皮网格的顶点随其绑定的关节移动，在数学上，要求一个矩阵，该矩阵能把网格顶点从原来位置（绑定姿势）变换至骨骼当前的姿势，称为蒙皮矩阵
- 与网格顶点相同，蒙皮顶点的位置在模型空间定义，无论骨骼的姿势，因此蒙皮矩阵将把顶点从绑定姿势的模型空间变换至当前姿势的模型空间，而不是变更基

##### 11.5.2.1 单个关节骨骼的例子

![image-20210607193456542](C:\Users\virtualqiu\AppData\Roaming\Typora\typora-user-images\image-20210607193456542.png)

- 求蒙皮矩阵的方法：
  - 顶点绑定至关节的位置时，在该关节坐标空间中是不变的
  - 首先将顶点在模型空间中的绑定姿势位置转换至关节空间
  - 再把关节移至当前姿势
  - 最后把该顶点转回模型空间
- 数学的形式：
  - 对一个顶点在其绑定位置，有其在模型空间内的坐标矢量$\bold V_M^B$
  - 首先将顶点位于模型空间内的坐标转变至关节空间内的坐标：
    - $\bold v_j=\bold v_M^B\bold B_{M\to j}$
  - 而模型空间转换至关节空间为关节空间至模型空间的逆转换，且关节空间至模型空间的转换为绑定姿势矩阵：
    - $\bold v_j=\bold v_M^B(\bold B_{j\to M})^{-1}$
  - 以矩阵$\bold C_{j\to M}$表示关节的当前姿势，则将$\bold v_j$从关节空间转换回模型空间：
    - $\bold v_M^C=\bold v_jC_{j\to M}$
  - 带入$\bold v_j$，展开有：
    - $\bold v_M^C\\=\bold v_M^B(\bold B_{j\to M})^{-1}\bold C_{j\to M}\\=\bold v_M^B\bold K_j$
  - 则联合后的矩阵$\bold K_j=(\bold B_{j\to M})^{-1}\bold C_{j\to M}$为蒙皮矩阵

##### 11.5.2.2 扩展至多个关节的骨骼

- 以上推导其实可以施于任何骨骼中的任何关节，为扩展以上的推导，需要做两个小调整
  - 确保矩阵$\bold B_{j\to M},\bold C_{j\to M}$使用各层子关节至其父关节的递推式计算完整
  - 计算一组蒙皮矩阵$\bold K_j$，其中每个矩阵对应的第$j$个关节，此数组称为矩阵调色板，当渲染一个蒙皮网格时，将全部的蒙皮矩阵传送至渲染器，渲染器对每个需要蒙皮的顶点查找其被绑定至的关节的蒙皮矩阵，并用该矩阵把顶点从绑定姿势变成当前姿势
- 在计算时的优化：
  - 绑定姿势逆矩阵存储于骨骼，为常量
- 多个关节的骨骼的计算流程：
  - 首先读取全身各节点的绑定姿势逆矩阵$\bold B_{j\to M}^{-1}$
  - 再将变换姿势，并计算每个关节的局部姿势$\bold C_{j\to p(j)}$
  - 通过局部姿势的递推转换，计算各个关节的全局姿势$C_{j\to M}$
  - 将全局姿势乘以对应的绑定姿势的逆矩阵，生成每个关节的蒙皮矩阵$\bold K_j$
  - 再将全身的顶点分别乘以其对应绑定的蒙皮矩阵

##### 11.5.2.3 引入模型至世界变换

- 每个顶点最终都会由模型空间变换至世界空间，有些引擎会预先乘以物体的模型至世界变换，这对每个蒙皮顶点可以减少一个矩阵乘法：
  - $(\bold K_j)_W=(\bold B_{j\to M})^{-1}\bold C_{j\to M}\bold M_{M\to W}$
- 某些情况下不提前变换至世界空间：
  - 同时对多个角色播放单个动画
  - 此时将模型至世界的变换剥离，以便将单个矩阵调色板应用至群众中的多个角色

##### 11.5.2.4 把顶点蒙皮至多个关节

- 分别将顶点蒙皮至每个关节，产生对于每个节点的模型空间位置
- 再以权值对多个位置进行加权平均，得到最终位置
- 权重和应为1，若不为1，应由管道进行归一化
- 对于N个数值$a_0$至$a_{N-1}$的对应权重$w_0$至$w_{N-1}$，并且$\sum w_i=1$，则数值的加权平均公式为：
  - $\displaystyle a=\sum_{i=0}^{N-1}w_ia_i$
- 同理对一个顶点蒙皮至$N$个关节，关节索引为$j_0-j_{N-1}$，权重为$w_0-w_{N-1}$，算式延伸为：
  - $\displaystyle \bold v_M^C=\sum_{i=0}^{N-1}w_i\bold v_M^B\bold K_{j_{i}}$
    - 其中$\bold K_{j_{i}}$是关节$j_i$的蒙皮矩阵

### 11.6 动画混合

- 动画混合：令一个以上的动画片段对角色最终姿势起作用的技术，即将两个或多个输入姿势结合，产生骨骼的输出姿势
  - 混合通常结合某个时间点的两个或以上的姿势，并生成同一时间点的输出
  - 混合用作结合两个或两个以上的动画，自动产生大量新动画，而无须手工制作这些动画
    - 如混合负伤及无负伤的步行动画，以得到不同程度负伤的动画
  - 混合也可以用于求出不同时间点的两个已知姿势之间的姿势
    - 当需要取得角色某时间点的姿势，但该时间点不是动画数据中的采样帧时，即可使用这种动画混合
  - 也可使用时间上的动画混合，通过再短时间内把来源动画逐渐混合至目标动画，即可把某动画平滑地过渡至另一动画

#### 11.6.1 线性插值混合

- 给定N个关节的骨骼，以及两个骨骼姿势$\displaystyle \bold P_A^{skel}={(\bold P_A)_j|_{j=0}^{N-1}},\bold P_B^{skel}={(\bold P_B)_j|_{j=0}^{N-1}}$，希望求得两极端的中间姿势$\bold P_{LERP}^{skel}$，方法之一为，对这两个来源姿势中每个关节的局部姿势进行线性插值，表示如下：

  - $(\bold P_{LERP})_j\\=LERP[(\bold P_A)_j,(\bold P_B)_j,\beta]\\=(1-\beta)(\bold P_A)_j+\beta(\bold P_B)_j$
    - $\beta$称为混合百分比，$\beta=0or1$即姿势为两种极端情况

- 对关节进行插值，但对矩阵插值难度较大，故通常使用SQT格式表示局部姿势，因此即对SQT中的每个部分进行插值：

  - 位移矢量$\bold T$：

    - $\bold T_{{LERP}_j}\\=LERP[(\bold P_A)_j,(\bold P_B)_j,\beta]\\=(1-\beta)(\bold T_A)_j+\beta(\bold T_B)_j$

  - 旋转四元数$Q$：

    - $Q_{LERP_j}=normalize((1-\beta)(Q_A)_j+\beta(Q_B)_j)$

      或

    - $\displaystyle Q_{SLERP_j}=\frac{\sin(1-\beta)\theta)}{\sin\theta}(Q_A)_j+\frac{\sin(\beta\theta)}{\sin\theta}(Q_B)_j$

  - 缩放标量$S_j$或$\bold S_j$：

    - $S_{LERP_j}=(1-\beta)(S_A)_j+\beta(S_B)_j$

- 对两个骨骼姿势进行线性插值时，自然的中间姿势通常是令关节在其父关节中间进行插值，即

  - 姿势混合通常在局部姿势进行

- 由于姿势混合在局部姿势进行，故每个关节姿势的线性插值完全独立于同一骨骼上的其他关节插值：

  - 线性插值可完全并行的计算（但一般一个骨骼实际只有上百个关节，将一个角色的关节并行插值可能降低内存存取的连贯性，导致性能下降；如果游戏中有大量角色，可以考虑以角色（骨骼）为最小单位进行并行处理）

#### 11.6.2 线性插值混合的应用

##### 11.6.2.1 时间性混合

- 通过改变$\beta$获取两个时间点的采样之间某一点的中间姿势
- 给定两个在时间点$t_1,t_2$的姿势采样，以下算式可以求得位于此期间时间点$t$的姿势：
  - $\bold P_j(t)=(1-\beta(t))\bold P_j(t_1)+\beta(t)\bold P_j(t_2)$
  - 混合因子$\beta(t)$，由$t$在两个时刻中间的比例决定：
    - $\displaystyle \beta(t)=\frac{t-t_1}{t_2-t_1}$

##### 11.6.2.2 动作连续性

- 游戏角色的动画由大量细粒度动画片段拼接而成，对于单个动作片段的自然真实较为容易，但要将一个片段过渡至另一片段的质量做到与单个动画一致是很难的

- 理想情况下，对于过渡中也应该保证骨骼中的每个关节移动时所描绘出的三娃路径不包含突然的跳跃，称为$C^0$连续：

  ![image-20210608120512909](C:\Users\89776\AppData\Roaming\Typora\typora-user-images\image-20210608120512909.png)

- 同时，路径之外，其第一导数（速度）曲线也应该连续，又称$C^1$连续，如果保证更高阶的连续性，则角色的动作会显得更加真实

- 通常难以达到数学上严格的$C^1$或以上的连续性，但可以使用LERP的动画混合达到不错的$C^0$动作连续性，这种混合也可以较好的逼近$C^1$连续性

- LERP在应用至过渡片段时，被称为淡入/淡出，LERP混合可能产生一些瑕疵（如脚滑）

- 对两个动画进行淡入/淡出，要把两个片段的时间线适度重叠

- 在开始时间$t_{start}$时，混合百分比$\beta$为0，混合之初只能看见片段A；然后逐步递增$\beta$，直至时间$t_{end}$时$\beta$为1，此时只能看见片段B

- 两种常见的淡入/淡出过渡方法如下：

  - 平滑过渡：
    - AB同时播放，同时递增$\beta$
    - 为了更好的效果，需要两个片段都为循环动画，且两个片段应该同步至手脚位置大致匹配
  - 冻结过渡：
    - 开始播放B时，片段A的局部时钟停顿，以停顿的这一帧中A的骨骼每次与B中播放的采样进行混合
    - 适用于混合两个不相关，且不难在时间上同步的片段

  ![image-20210608133732983](C:\Users\89776\AppData\Roaming\Typora\typora-user-images\image-20210608133732983.png)

- 为了得到更平滑的过渡，可以令$\beta$按时间的三次函数变化：

  ![image-20210608133747083](C:\Users\89776\AppData\Roaming\Typora\typora-user-images\image-20210608133747083.png)

  - 表达式如下：
    - $\displaystyle u=\frac{t-t_{start}}{t_{end}-t_{start}}$
    - $v=1-u$
    - $\beta(t)=(v^3)\beta_{start}+(3v^2u)T_{start}+(3vu^2)T_{end}+(u^3)\beta_{end}$
    - 令切线$T_{start},T_{end}$被设为对应的混合因子$\beta_{start},\beta_{end}$
    - $\beta(t)=(v^3+3v^2u)\beta_{start}+(3vu^2+u^3)\beta_{end}$

- 核心姿势：
  - 不需要混合即可产生连续动作的方法：确保某片段的最后姿势能匹配后续片段的首个姿势
  - 实践中通常制定一组核心姿势，如包括一个直立的核心姿势、一个蹲下姿势、一个躺下姿势等
    - 只要能确保角色的每个动画片段从某核心姿势开始，
    - 再以某核心姿势结束，
    - 就能简单地把核心姿势匹配的片段连接成具有$C^0$连续性的动画
    - $C^1$或更高阶的连续性动画也可做到，只要确保角色再片段结束时动作能平滑地过渡至后续片段开始时的动作，具体如将一段平滑的动画再将其切分为两个或两个以上的动画片段

##### 11.6.2.3 方向性运动

- 基于LERP的动画混合通常应用在角色运动中，真实人类在步行/跑步中有两种方式改变移动方向：

  ![image-20210608140211320](C:\Users\89776\AppData\Roaming\Typora\typora-user-images\image-20210608140211320.png)

  - 轴转移动：
    - 转身改变方向，一直面向移动方向
  - 靶向移动：
    - 保持面向某方向，但同时可以朝前后左右步行

- 轴转移动：

  - 简单播放向前运动循环片段，同时以垂直轴旋转整个角色
  - 为更加真实，可使角色在转向时不保持完全笔直，稍微产生一定倾斜，但这会导致角色内脚插入地面，外脚翘起
  - 因此可以使用3个向前步行或跑步的动画，一个完全向前，一个极端左转，一个极端右转，再使用LERP对这些动画进行混合，以产生任意想要的倾斜角

- 靶向移动：

  - 为实现靶向移动，需要制作3种不同的循环动画片段，包括向前、向左及向右移动，将这3个片段排列再一个半圆圆周上：

    ![image-20210608141809574](C:\Users\89776\AppData\Roaming\Typora\typora-user-images\image-20210608141809574.png)

  - 只要使角色面对方向对齐至$0°$，就能在半圆上求得移动方向，然后旋转该角度上的两个相邻片段以LERP方式混合，混合百分比$\beta$由移动角度和相邻片段的角度求得

  - 在此并未在混合中包含向后移动以形成一个全周的混合：

    - 左右移动和向后移动的直接混合，由于左右移动时左右脚的前后不一致会出现腿部穿模
    - 一种解决方法是定义两个半圆混合，一个用作向前移动，一个用作向后移动，再为这两个半圆分别制作两组适合混合的左右移动动画，当从一个半圆切换至另一半圆时，可以加入明确的过渡动画，使角色调整步伐及跨步

#### 11.6.3 复杂的线性插值混合

- 真实的游戏引擎中，角色会使用不同种类的复杂混合，以达到不同的目的，为了更易使用，通常将几个常见的复杂混合封装起来

##### 11.6.3.1 泛化的一维线性插值混合

![image-20210608144443343](C:\Users\89776\AppData\Roaming\Typora\typora-user-images\image-20210608144443343.png)

- 将LERP扩展至多于两个动画片段
- 定义新的混合参数$b$，可任意指定此参数的范围
- 同时将任意数量的片段置于此范围中的某点之上
- 对给定的任意$b$值，选取两个距离$b$值最近的片段，并用算式混合两者，记两片段分别位于点$b_1,b_2$，则混合百分比$\beta$如下：
  - $\displaystyle \beta(b)=\frac{b-b_1}{b_2-b_1}$
- 靶向移动为一维LERP的特例

##### 11.6.3.2 简单的二维线性插值混合

- 平滑的同时改变角色动作的两个方面
- 若所需的二维混合只涉及4个动画片段，且这些片段位于一个正方形区域的四个角，则可以用3个一维混合求得混合姿势
- 令广义混合因子$\bold b=\begin{array}{}[b_x&b_y]\end{array}$，则混合过程如下：
  - 利用水平混合因子$b_x$求出两个中间姿势
  - 利用垂直混合因子$b_y$求出两个中间姿势的混合

##### 11.6.3.3 三角形的二维线性插值混合（？）

- 使用3维LERP混合三个动画片段：
  - $(\bold P_{LERP})_j=\alpha(\bold P_0)_j+\beta(\bold P_1)_j+(1-\alpha-\beta)(\bold  P_2)_j$

- 类似在三角形内任意找到一点：

  - $\bold b=\alpha\bold b_0+\beta\bold b_1+\gamma \bold b_2$
  - $\alpha+\beta+\gamma=1$

  ![image-20210608155256038](C:\Users\89776\AppData\Roaming\Typora\typora-user-images\image-20210608155256038.png)

##### 11.6.3.4 泛化的二维线性插值混合

- 利用Delaunay三角剖分技术，从多个动画片段位置$b_i$求出一组三角形，得到这些三角形后从中寻找包围混合点$b$的三角形，再在该三角形上使用三片段LERP

#### 11.6.4 骨骼分部混合

- 骨骼分部混合：如人可独立控制身体的不同部位
- 对正常的LERP，允许每个关节设置不同的混合百分比
- 即对每个关节$j$定义一个独立的混合百分比
- 整个骨骼的混合百分比集合：${\beta_j}|_{j=0}^{N-1}$，被称为混合遮罩
  - 因为可以将某些关节的混合百分比设置为0，以掩盖这些关节
    - 如令角色挥手，首先有全身动作步行、跑步及站立
    - 再创建一挥手动作，
    - 则可以创建一个混合遮罩，在遮罩中，将右肩、右肘、右腕及右手手指关节的混合百分比设为1，其他关节百分比设为0
    - 以此，在角色行动时使用此混合遮罩，即可让角色在移动的同时挥动右手
- 骨骼分部混合会导致不自然的角色动作：
  - 相连关节的混合因子突变，导致身体部分动作与其他动作分离
    - 可以逐渐改变混合因子，而不是突变（如自树的根至叶依次增大混合系数）
  - 现实中人体的动作并非完全独立，当人在跑步时，玩家会更倾向于认为挥手会更加晃动，但这无法被骨骼分部混合解决

#### 11.6.5 加法混合

- 区别片段动画：两段正常动画的区别，存储一个姿势至另一个姿势的改变，区别动画可以被加进普通的动画片段，以产生有趣的姿势和动作变化
- 输入两片段：来源片段（S）和参考片段（R），则区别片段定义为$D=S-R$
  - 若将区别片段$D$加入原本的参考片段，则将取回来源片段
  - 若将某比例的$D$加入原本的参考片段，则可以产生介于$R$和$S$之间的动画，如同使用LERP为两个极端片段找出中间动画
- 但加法混合技术可以在制作一个区别片段后，将其加入其他不相关的片段（目标动画，T），而不仅限于原来的参考片段

##### 11.6.5.1 数学公式

- 关节姿势是一个$4\times 4$的仿射矩阵$\bold P_{C\to P}$，此矩阵会把点或矢量从子关节的局部空间变换至其父关节的空间
- 对矩阵，等价于标量减法的运算为乘以逆矩阵，故给定骨骼中每个关节$j$的来源姿势$\bold S_j$及参考姿势$\bold R_j$，区别姿势$\bold D_j$可定义如下：
  - $\bold D_j=\bold S_j\bold R_j^{-1}$
- 将区别姿势$\bold D_j$加进目标姿势$\bold T_j$会产生新的加法姿势$\bold A_j$，只需要简单的串接区别变换及目标变换：
  - $\bold A_j=\bold D_j\bold T_j=(\bold S_j\bold R_j^{-1})\bold T_j$
- 不同动画短片的时间性插值：
  - 游戏动画机会不在整数帧上插值，故为了获得任意时间t的姿势，需要对来源姿势和参考姿势进行时间上LERP的插值
  - 同时需要输入的片段$S$和$R$持续时间相同，以保证全部时间内都有区别动画的定义
- 加法混合百分比：
  - 可通过LERP实现加法混合的百分比，即对初始的目标姿势和执行加法后的加法姿势进行LERP插值：
    - $\bold A_j\\=LERP(\bold T_j,\bold D_j\bold T_j,\beta)\\=(1-\beta)\bold T_j+\beta\bold D_j\bold T_j$
    - 注意插值需要使用SQT形式

##### 11.6.5.2 比较加法混合和分部混合

- 加法混合部署取代一组关节的动画，也不是对两个可能无关的姿势进行插值，而是将动作加入原本的动画内，动作可能横跨整个骨骼
- 区别动画含有如何改变角色的姿势来得到具体效果的信息，这些信息可以运用在其他动画上，同时效果比较自然

##### 11.6.5.3 加法混合的局限

- 可能导致骨骼中关节旋转过度
- 注意点：
  - 参考片段中，尽量减少髋关节的旋转
  - 参考片段中，肩及肘关节应该始终维持中性姿势，则将区别片段加入其他目标时，即可减轻手臂过度旋转的问题
  - 应为每个核心姿势创建新的区别动画

#### 11.6.6 加法混合的应用

##### 11.6.6.1 站姿变化

- 动画师对每个站姿创建1帧的区别动画，当这些单帧片段用加法混合混合至一个基本动画时，角色的站姿就会发生改变，但可以同时表现原本的动作

##### 11.6.6.2 移动噪声

- 现实中人运动时的每个脚步都不会完全一致，在人分心时更加明显
- 可以通过加法混合在完全重复的移动周期上叠加随机性、反应和分心的表现

##### 11.6.6.3 瞄准及注视

- 首先用动画令角色执行一些动作，如跑步，其中头部和武器都朝向前方
- 然后改变头部或武器方向至最右，并存储该帧或多帧的区别动画（最左、最上、最下同理）
- 则这四个区别动画就能用加法混合混合至原来的向前动画，产生向上、向下、向左、向右及之间的注视或瞄准动画

##### 11.6.6.4 时间轴的另类用途

- 动画片段的时间轴并不一定表示时间：
  - 如三帧动画表示三个瞄准姿势，第1帧向左瞄准，第2帧向前、第三帧向右
  - 要令角色向右瞄准，可将瞄准动画的局部时钟固定至第3帧
  - 为产生50%向前和向右的瞄准，只需将时钟拨至2.5帧















