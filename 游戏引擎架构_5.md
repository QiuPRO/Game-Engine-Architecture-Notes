[toc]

## 5 游戏支持系统

- 底层支持系统：管理例行且关键的任务，如：
  - 启动及终止引擎
  - 存取（多个）文件系统
  - 存取各种不同类型的资产（网格、纹理、动画、音频等）
  - 为游戏团队提供调试工具

### 5.1 子系统的启动和终止

- 游戏引擎由多个相互合作的子系统结合而成，当引擎启动时，必须依次配置及初始化各个子系统
- 各子系统的相互依赖关系隐含地定义了每个子系统所需地启动次序
- 各子系统地终止通常会采用反向次序

#### 5.1.1 C++的静态初始化次序

- C++中，在调用程序进入main()前，全局及静态对象已被构建，且无法预知构造函数的调用次序，再析构时也无法判断函数的调用顺序，因此C++的行为不适合用于初始化及终止游戏引擎的子系统
- 游戏引擎的子系统通常使用单例模式

##### 5.1.1.1 按需构建

- C++中，函数内声明的静态变量不会在main()之前构建，可以采用如下的方式将全局单例改为静态变量，以控制全局单例的构建次序：

  ```c++
  class RenderManager
  {
  public:
      static RenderManager& get()
      {
          static RenderManager sSingleton;
          return sSingleton;
      }
      RenderManager()
      {
          // 对于需依赖的管理器，先调用其get()进行创建
          VideoManager::get();
          TextureManager::get();
          // 启动渲染管理器
      }
      ~RenderManager()
      {
          // 终止管理器
      }
  }
  ```

- 另一种单例方式：

  ```c++
  static RenderManager& get()
  {
  	static RenderManager* gpSingleton = nullptr;
  	if (gpSingleton == nullptr)
  		gpSingleton = new RenderManager;
  	return *gpSingleton;
  }
  ```

  - 但此方法无法控制析构顺序，无法保证在RenderManager析构之前，其依赖的单例未被析构
  - 同时无法预测单例构建的时间
  - 也增大了get()的开销

#### 5.1.2 行之有效的简单方法

- 明确地为各单例管理器类定义启动和终止函数，并使这些函数替代其构造函数和析构函数，如此即可在main()中以明确地次序调用各启动和终止函数
- 或更进一步让各管理器将自己登记在一个全局的优先队列中，之后再按恰当的次序逐一启动所有管理器；或形成管理器间的依赖图，按照相互依赖关系形成最优启动次序

#### 5.1.3 一些实际引擎的例子

##### 5.1.3.1 OGRE

- OGRE所有的对象都由Ogre::Root单例控制，此单例指向其他OGRE子系统的指针，并负责启动和终止这些子系统
- OGRE提供了一个Ogre::Singleton模板基类，所有管理器都派生自此基类

##### 5.1.3.2 顽皮狗的神秘海域系列和最后生还者

- 可行的情况下，代码会尽量避免动态内存分配，故许多单例是静态分配的对象

### 5.2 内存管理

- 内存的效能的影响：
  - 使用malloc()或new进行动态内存分配操作耗时长；为提升性能，应该尽量避免动态内存分配，也可使用自制的内存分配器以降低分配成本
  - 现代CPU上，软件的效能受其内存访问模式影响，数据被置于细小连续内存较数据被分散至广阔的内存地址空间，CPU的处理速度会更快

#### 5.2.1 优化动态内存分配

- 动态内存分配低效的原因：
  - 堆分配器是通用的函数，因此需要处理任何大小的分配请求，会耗费大量的管理开销
  - 多数操作系统中，malloc()和free()必然从用户态切换至内核态处理请求，再切换回原本的程序，上下文切换耗时长
- 经验法则：
  - **维持最低限度的堆分配，并且永不再紧凑循环中使用堆分配**
- 游戏引擎无法避免动态内存分配，故都会实现一个或多个定制分配器，其性能比操作系统分配器性能更优：
  - 定制分配器从预分配的内存中完成分配请求，完全在用户模式下完成，避免了内核态用户态的切换
  - 对定制分配器的使用模式提出多个假设，以提高分配效率

##### 5.2.1.1 基于堆栈的分配器

- 适用场景：
  - 许多游戏会以堆栈的方式分配内存：
    - 当载入新的游戏关卡时，为游戏分配内存，关卡载入后就很少或不会动态分配内存；
    - 完成关卡后，关卡的数据被卸下，所有关卡占用的内存被释放
- 堆栈分配器的实现：
  - 分配一大块连续内存：使用malloc()，全局new，或是声明一个全局字节数组（实际是从BSS段分配）
  - 对每个分配请求，仅把指针往上移动请求所需的字节数
  - 释放最后分配的内存块，也只需要把指针向下移动该内存块的字节数量
  - 堆栈分配器不能以任意次序释放内存，必须以分配时相反的次序释放内存，简单的限制法：
    - 完全不允许释放个别内存块，但提供一个函数，该函数可以把堆栈顶端指针回滚至之前标记了的位置，即释放回滚点至目前堆栈顶端之间的所有内存
  - 回滚顶端指针时，回滚的位置必须位于两个分配而来的内存块之间的边界，为保证能正确地回滚指针，堆栈分配器通常提供一个函数，该函数传回一个标记，代表目前堆栈的顶端，而回滚函数则使用该标记为参数

![image-20210601222854186](C:\Users\89776\AppData\Roaming\Typora\typora-user-images\image-20210601222854186.png)

- 双端堆栈分配器
  - 一块内存可以给两个堆栈分配器使用，一个从内存块的底端向上分配，另一个从顶端向下分配
  - 如使用底堆栈载入及卸下游戏关卡，而顶堆栈用来分配临时内存块（会在每帧中被分配及释放），可以避免产生内存碎片

##### 5.2.1.2 池分配器

- 适用场景：
  - 分配大量同等尺寸的小块内存，如分配及释放矩阵、迭代器、链表中的节点、可渲染的网格实例等
- 工作方式：
  - 预分配一大块内存，大小为分配元素大小的倍数
  - 池内每个元素被加在一个存放自由元素的链表：
    - 对池初始化时，自由列表包含所有元素
    - 池分配器收到分配请求时，把自由链表的下一个元素取出，并传回该元素
    - 释放元素时，只需简单地把元素插回自由链表中
- 自由列表的实现：
  - 单链：
    - 每个自由元素需要一个指针，当$elementSize\geq sizeof(void *)$时，不需要额外开辟空间，而是使用自由列表内存块本身的内存，存储自由列表的next指针
  - 池元素的索引代替指针：
    - 当$elementSize< sizeof(void *)$时，使用池元素的索引代替指针实现链表
    - 如若池是用于存放16位整数的，则可在链表中使用16位索引作为next指针，只要池内元素不超过索引数量即可

##### 5.2.1.3 含对齐功能的分配器

- 数据对象和变量都有对齐要求，所有内存分配器都必须能传回对齐的内存块
- 实现：
  - 分配时比请求所需多一点的内存，再向上调整其内存地址至适当的对齐，最后传回调整后的地址。
  - 大多数实现中，额外分配的字节等于对齐字节，如对齐字节为16，则多分配16字节
  - 调整偏移量的计算：
    - $掩码=对齐字节-1 \\(16-1=15)$
    - $错位字节=掩码\&原本内存地址\\(0\bold x0000000F\&0\bold x50341233=0\bold x00000003)$
    - $对齐地址=(原本内存地址+对齐字节-错位字节)\\(0\bold x50341233+0\bold xF-0\bold x3=0x50341240)$
  - 调整的偏移量存储于调整后地址之前的1字节，用以计算原本的地址，消去偏移量

##### 5.2.1.4 单帧和双缓冲内存分配器

- 适用场景：

  - 分配临时数据，这些数据要么可在循环迭代结束时被丢弃，要么可在下一迭代结束时被丢弃

- 单帧分配器：

  - 先预留一块内存，并以前文所述的简单堆栈分配器管理，在每帧开始时，把堆栈的顶端指针重置到内存块的底端地址，在该帧中，分配要求会使堆栈向上成长，此过程不断重复

    ```c++
    StackAllocator g_singleFrameAllocator;
    
    // 主游戏循环
    while (true)
    {
        g_singleFrameAllocator.clear();
        // ...
        
        // 从单帧分配器分配内存
        // 不需要手动释放这些内存，但要确保这些内存仅在本帧内使用
        void* p = g_singleFrameAllocator.alloc(nBytes);
        
        // ...
    }
    ```

  - 好处：

    - 分配的内存用不用手动释放，依赖每帧开始时分配器自动清楚所有内存

  - 坏处：

    - 要求程序员保证单帧分配器分配的内存块只在目前的帧内有效

- 双缓冲分配器：

  - 允许在第$i$帧分配的内存块用于第$i+1$帧，实现的方法是建立两个相同尺寸的单帧堆栈分配器，并在每帧交替使用

    ```c++
    class DoubleBufferedAllocator
    {
        U32 			m_curStack;
        StackAllocator 	m_stack[2];
    public:
        void swapBuffers()
        {
            m_curStack = (U32)!m_curStack;
        }
        
        void clearCurrentBuffer()
        {
            m_stack[m_curStack].clear();
        }
        void * alloc(U32 mBytes)
        {
            return m_stack[m_curStack].alloc(nBytes);
        }
        
        //...
    }
    
    DoubleBufferedAllocator g_doubleBufAllocator;
    
    // 主游戏循环
    while (true)
    {
        // 单帧分配器清除
        g_singleFrameAllocator.clear();
        
        // 双缓冲分配器交换现行和无效的缓冲区
        g_doubleBufAllocator.swapBuffers();
        // 清空新的现行缓冲区，保留前帧的缓冲不变
        g_doubleBufAllocator.clearCurrentBuffer();
        
        // ...
        
        // 从双缓冲分配器分配内存，不影响前帧的数据
        // 要确保这些内存仅在本帧或次帧内使用
        void *p = g_doubleFrameAllocator.alloc(nBytes);
        
        // ...
    }
    ```

  - 在多核游戏机中，在缓存非同步处理的结果时，这类分配器极有用（多线程缓冲）

#### 5.2.2 内存碎片

- 动态堆分配的另一个问题：产生内存碎片——有足够的自由内存，但并不连续，导致分配失败
- 在支持虚拟内存的操作系统中，内存碎片并非大问题，但在某些游戏机上无法支持虚拟内存，或开销过大，多数游戏引擎不会使用虚拟内存

##### 5.2.2.1 以堆栈和池分配器避免内存碎片

- 堆栈和池分配器完全避免了内存碎片的出现，或避免了无法申请足够的空间

##### 5.2.2.2 碎片整理及重定位

- 若要分配及释放不同大小的对象，并以随机次序进行，则不适用堆栈和池分配器，对此，应对堆定期进行碎片整理
- 简单的算法是寻找洞，并将洞上方紧接着的已分配内存块往下移至洞的开始地址
  - 存在的问题：
    - 若有指针指向已分配的内存块，则移动内存会使这些指针失效
  - 解决方法：
    - 指针重定位，将指向这些内存块的指针逐一更新，使移动内存块后这些指针能指到新的地址，但在C++中没有方法可以搜寻所有指向某地址范围的指针
    - 舍弃指针，使用在重定位时更容易进行修改的构件，如智能指针或句柄（handle）
- 智能指针：
  - 让所有智能指针把自己加进一个全局链表内
  - 当要移动某块内存时，扫描该全局链表，更新每个指向该内存的智能指针
- 句柄：
  - 实现为索引，索引指向句柄表内的元素，每个元素存储指针
  - 句柄表本身不能被重定位，当要移动某已分配内存块时，则扫描句柄表，并自动修改相应的指针

- 重定位的另一问题：
  - 某些内存块可能无法重定位，如使用了第三方库，而该库不使用智能指针或句柄，则指向库内数据结构的指针就可能不能被重定位
  - 解决方法：
    - 让这些库在另一个特别缓冲区内分配内存
    - 或允许一些内存块不能被重定位，若这种内存块数量少且体积小，则重定位系统仍可以运行的很好
- 分摊碎片整理成本
  - 碎片整理进行复制内存块的操作可能很慢，但不需要一次性整理完全部的碎片，而可以将碎片整理的成本分摊至多个帧
  - 此方法只对细小的内存块有效，使移动内存块的时间短于每帧被分配的重定位时间，若要重定位非常大的内存块，有时可以将其拆分为两个或更多小块，每个小块可以被独立重定位

### 5.3 容器

- 集合型数据，安置及管理零至多个数据元素
- 常见的容器数据类型：
  - 数组
  - 动态数组（std::vector）
  - 链表（std::list）
  - 堆栈（std::stack）
  - 队列（std::queue）
  - 双端队列（std::deque）
  - 优先队列（std::priority_queue）
  - 树：图的特例
  - 二叉查找树（红荷数、伸展树、AVL树）
  - 二叉堆（用来实现优先队列）
  - 字典：键值对组成的表，又称map或散列表hash table（std::map,std::unordered_set）
  - 集合：没有重复元素，只有键没有值的字典（std::set,std::unordered_set）
  - 图
  - 有向无环图（DAG）

#### 5.3.1 容器操作

- 插入（insert）
- 移除（remove）
- 顺序访问/迭代：按某种自然顺序访问容器内的每个元素
- 随机访问：以任意次序访问容器中的元素
- 查找
- 排序

#### 5.3.2 迭代器

```c++
void processList(std::list<int>& container)
{
	for (std::list<int>::iterator p = container.begin(); p != container.end(); p++){
        int element = *p;
        // 处理元素
    }
}
```

- 迭代器的优点：
  - 直接访问会破坏容器类的封装，而迭代器是容器的友元，可以高效迭代访问容器，并且不暴露容器类地实现细节（优秀地容器类隐藏内部细节，只允许使用迭代器访问其内容）
  - 简化了迭代过程，迭代器行为与数组索引或指针相似，无论构成容器的数据结构有多复杂，用户都可以编写一个简单的循环，每次把迭代器递增，并检测终止条件

##### 5.3.2.1 前置递增与后置递增

- ++p$\leftrightarrow$p++
  - ++p造成CPU的数据依赖，CPU必须先完成递增运算后，才能在表达式内使用该变量的值，会引起流水线的停顿
  - 而p++不造成数据依赖，可立即使用变量的值，而后递增，不会造成CPU流水线停顿
  - 在for循环更新表达式中，二者没有区别，但使用到值时，后置递增更优越
- 但在类类型变量中，编译器必须按前置/后置来调用重载运算符，后置递增需要对对象进行复制，如果这些运算符不是内联的，编译器可能无法消除对象赋值，造成性能损耗，故应使用前置递增

#### 5.3.3 算法复杂度

#### 5.3.4 建立自定义的容器类

- 建立自定义容器的原因：
  - 完全掌控：能控制数据结构的内存需求、使用的算法、何时/如何分配内存
  - 优化的机会
  - 可定制性
  - 消除外部依赖
  - 操控并发数据结构：全权控制其在多线程或多核系统中的保护机制

##### 5.3.4.1 建还是不建

- 游戏引擎数据结构的选择：
  - 自行建立所需的数据结构
  - 依赖第三方实现：
    - C++标准模板库（STL）
    - STL的变种
    - Boost库

- STL：
  - 优势：
    - 功能丰富
    - 许多平台上都有尚算健壮的实现
    - 几乎所有的C++编译器都带有STL
    - 适用于PC运行的游戏引擎
  - 缺点：
    - 难以学习
    - 比起专用的数据结构，STL通常速度较慢
    - 比起自行设计的数据结构，STL通常占用内存更多
    - STL会进行许多动态内存分配，对高性能，内存受限的游戏机游戏而言，控制STL的内存占用较难，不适合游戏主机
    - STL的实现和行为在各编译器上有微小差异，增加了多平台引擎上应用STL的难度，移植性差
  - 使用STL：
    - 认识其效能和内存特性
    - 如果认为代码中的重量级STL类会造成瓶颈，尝试避免使用它们
    - 占用少量内存的情况下才使用STL
    - 若引擎需要支持多平台，则使用STLport
- Boost：
  - 功能简介：
    - 提供了许多有用但STL没有的功能
    - Boost提供了替代方案，能解决一些STL设计或实现上的问题
    - Boost能有效处理一些复杂问题（智能指针）
    - 大部分Boost库文档写得很好
  - 注意：
    - 大部分Boost核心类都是模板，使用多数Boost功能时只需要包含一些头文件，但有些Boost库会生成较大得.lib文件，可能不适合非常小型得游戏项目
    - Boost也可能存在bug
    - Boost库不保证支持向后兼容
- Loki
  - 模板元编程

##### 5.3.4.2 动态数组和大块分配

- 动态数组：如std::vector变长数组
- 为数据设立一个高水位线，在引擎开始时就分配该大小的缓冲区
- 动态数组在开发期可能是最优选择，但在能确定适当的内存预算时，就可以把动态数组改为固定大小的数组

##### 5.3.4.3 链表

- 适用场景：主要考虑能任何位置高效插入及移除元素，而不是考虑内存的连续性

- 链表节点：

  ```c++
  template< typename ELEMENT>
  struct Link
  {
      Link<ELEMENT>* 	m_pPrev;
      Link<ELEMENT>* 	m_pNext;
      ELEMENT*		m_pElem;
  }
  ```

- 外露式表

  - 其节点数据结构完全和元素的数据结构分离，每个节点含指针指向元素，如上述例子
  - 优点：一个元素可以同时置于多个链表中，只需为每个链表分配独立的节点
  - 缺点：必须动态分配内存，通常使用池分配器分配节点，因为每个节点同等大小

- 侵入式表：

  - 其节点的数据结构被嵌进目标元素本身
  - 优点：无须动态分配节点，每次分配元素时就获得了节点，消去节点内指向元素的指针

  ```c++
  template< typename ELEMENT>
  struct Link
  {
      Link<ELEMENT>* m_pPrev;
      Link<ELEMENT>* m_pNext;
  }
  
  class SomeElement : public Link<SomeElement>
  {
      // 其他成员
  };
  ```

  - 缺点：每个元素不能同时置于多个链表中，若要把元素同时加进N个链表，可在元素中加入N个节点成员（则无法使用继承方式），但N的值必须事先固定，侵入式表不如外露式表有弹性

- 如何选择：

  - 如果需要避免动态内存分配，则适合使用侵入式表
  - 如果可以负担池分配的开销，则可以使用外露式表

- 循环链表

  - 完整的链表实现还需提供头尾指针，简单的方式是将两个指针包装成为一个独立的数据结构：

    ```c++
    template< typename ELEMENT>
    class LinkedList
    {
        Link<ELEMENT>* m_pTail;
        Link<ELEMENT>* m_pHead;
        
        // 操作列表的成员函数
    }
    ```

  - 注意到LinkedList和Link的区别不大，故可以使用Link类管理头尾指针：

    ```c++
    template< typename ELEMENT>
    class LinkedList
    {
        Link<ELEMENT> m_pTail; // 包含头和尾
        
        // 操作列表的成员函数
    }
    ```

    - 于是链表真正的头节点和尾节点都会指向m_root
    - 这简化了循环链表的的remove操作，保证节点的先导和后置不会为空指针

- 单向链表

  - 单向链表可以节约内存
  - 但单向链表的插入和删除时间复杂度为$O(n)$，较双向链表高
    - 但移除单向链表某节点的下一节点的复杂度是$O(1)$故应该提供删除下一节点的API，并尽量使用

##### 5.3.4.4 字典和散列表

- 字典是由键值对组成的表，在字典中，用键可以快速查找对应的值，键和值可以是任何数据类型，通常用二叉查找树或散列表实现
- 碰撞
  - 开放式散列表
    - hash值冲突时，以冲突链表存储，需要动态分配内存
  - 闭合式散列表
    - 内存固定，冲突时进行探查，散列表大小最好为质数
    - 线性探查
    - 二次探查，结合质数大小往往能得到表位置的最佳覆盖
- 散列法：
  - 哈希函数：对键值k产生对应的整数散列值h，再求出表的索引i：
    - $h=H(k)\\i=h\mod{N}$
  - 哈希函数的质量影响散列表的性能，哈希函数是确定性的，相同的输入会有完全相同的输出

### 5.4 字符串

#### 5.4.1 字符串的使用问题

- 如何存储和管理字符串，可能需要使用动态内存分配
- 字符串的本地化（localization）：
  - 更改软件以发布其他语言的过程，翻译为需要支持的语言、使用字体、处理文本方向
- 字符串作为资源名
- 处理内部字符串的效率极大的影响游戏的性能

#### 5.4.2 字符串类

- 方便
- 但存在隐性成本，字符串数组只需要传递指针，但字符串对象可能引起大量拷贝
- 一般避免使用，必须使用则注意：
  - 检查其运行性能特性是否再可接受的范围
  - 是否把所有字符缓冲区当作只读的
  - 是否使用了写入时复制优化
  - 有没有提供移动构造函数
  - 尽早剖析代码性能，确定字符串是否是掉帧的主要原因
- 存储和管理文件系统路径可以使用字符串类：
  - 相较于C风格字符串，可以添加许多功能，如提供函数从路径中提取文件名、文件扩展名或目录
  - 也可以因此操作系统之间的差异，如自动转换Windows风格的反斜线至UNIX风格的正斜线，以便于跨平台

#### 5.4.3 唯一标识符

- 游戏引擎可以通过唯一标识符寻找和操控游戏对象
- 字符串是唯一标识符的自然选择，如路径、游戏对象的名字
- 但对比较标识符的效率存在要求，而字符串比较速度慢

##### 5.4.3.1 字符串散列标识符

- 通过hash函数，将字符串映射至半唯一整数
- 如果将字符串存于hash表，则可通过对应的hash至取回原本的字符串，以便调试输出
- 散列碰撞：（两个不同的字符串有相同的hash值）
  - 如果存在恰当的hash函数，则可以保证合理的字符串输入基本不会发生碰撞
  - 若出现碰撞，则简单的修改一下字符串

##### 5.4.3.2 一些关于实现的想法

- 使用hash函数产生字符串标识符比较容易
- 但何时计算散列是一个问题，多数采用字符串标识符的游戏引擎会在运行时进行散列，但也可以使用简单工具预处理源代码，将每个SID（任何字符串）的宏直接翻译为相对的散列值
  - 如此，在任何整数常数能出现的地方，都可以使用字符串标识符，包括switch语句中case标签的常数
- 从字符串产生字符串标识符的过程称为字符串扣留（string interning），除了产生字符串的散列值，同时将其存在全局字符串表内
- 字符串扣留的问题是速度慢，因此最好只调用一次hash函数，并同时保存下string对应的哈希值，以供后续的调用
  - 另一种思想：将字符串标识符和相应的C风格字符串包装进一个细小的类
- 利用调试内存存储字符串：字符串本身在发行时是不需要的，因此可以将其以字符串标识符替代以减小内存开销

#### 5.4.4 本地化

##### 5.4.4.1 Unicode

- 将全球的每个常用语言中的每个字符或字形赋与一个唯一的十六进制码点，在内存中存储字符串时，会选择某一种编码，然后依据这些规则去编排内存中的位序列以表示字符串
- UTF-32：
  - 最简单的Unicode编码，每个Unicode码点都被编码成一个32位值，
  - 缺点：浪费很多空间，如英语编码不需要使用高16位的码点
  - 优点：定长
- UTF-8：
  - 每个字符的码点以8位的粒度存储，但有些码点占多于1字节的空间，故UTF-8字符串所占的字节数量并不一定等于其长度，为可变长度编码
  - 优点：向后兼容ASCII编码，同时由于ASCII码只使用了$0-127$之间的数，故首字节最高位为1的字符不会引起歧义
- UTF-16：
  - 较简单但更昂贵，每个字符使用1个或2个16位值
  - 所有Unicode码点被分到17个平面，每个平面含有$2^{16}$个码点，首个平面被称为基本多文种平面，含有众多语言中最常用到的码点，大部分UTF-16字符串可以完全使用BMP中的码点表示，若字符串中含有其他平面（补充平面）的字符，则需要使用两个连续的16位数值
  - UCS-2编码是UTF-16编码的有限子集，仅使用基本多文种平面，保证了每个字符都是16位

##### 5.4.4.2 char与wchar_t

- 标准C/C++库为字符串定义了两种数据类型：char和wchar_t
- char用于存储ANSI字符串以及多字节字符集MBCS（包括UTF-8）
- wchar_t是宽字符类型：足够用单个整数表示任何合法码点，故尺寸和编译器及系统相关的
- 由于wchar_t定义的歧义性，为编写可携的字符处理代码，需要定义自己的（多种）字符编码类型，并提供函数库处理所需支持的（多种）Unicode编码

##### 5.4.4.3 Windows下的Unicode

- Windows下，wchar_t数据类型完全用于表示UTF-16编码的U你从的字符串，而char则用作ANSI字符串及旧Windows代码页字符串编码

##### 5.4.4.4 游戏机上的Unicode

- 使用哪种编码并不是特别重要，重要的是能在项目中尽早决定，并贯彻始终

##### 5.4.4.5 其他本地化要考虑的事情

- 字符串并非本地化问题的全部，音频片段、纹理中的字符可能也需要翻译，以及游戏分级的问题
- 字符串也有细节：需要管理一个数据库，其中存放游戏中玩家可以看到得所有字符串，如此才能进行可靠的翻译
- 本地化系统中，最关键的组件是存储人类可读字符串的数据库，同时需要以某全局方式设定当前语言
- 不要向玩家显式原始字符串，必须使用数据库中的字符串标识符，并通过查找函数取得所需字符串

##### 5.4.4.6 案例分析

### 5.5 引擎配置

- 游戏引擎通常提供大量可调校选项，有些选项供玩家调整；有些专为开发团队设置，在游戏发行时会被隐去

#### 5.5.1 读/写选项

- 可配置选项可被简单实现为全局变量或单例类中的成员变量，可配置选项必须供用户配置，并被存储至硬盘，以供后续游戏的使用
- 简单的读/写可配置选项的实现方法：
  - 文本配置文件：将选项置于一个或多个文本文件中，以键值对存储，或使用XML格式存储
  - 经压缩的二进制文件：在旧游戏机上会使用可取出的记忆卡，游戏选项有时会连同游戏存档一起写在记忆卡上，使用记忆卡为节省空间，会将数据压为二进制文件
  - Windows注册表：Windows系统提供一个全局选项数据库，名为注册表，注册表以树状形式存储，其内部节点称为注册表项，任何游戏和软件都可预留整个子树供该软件专用，并在该子树下存储任意选项集
  - 命令行选项：引擎可提供机制使所有游戏中的选项都能经命令行设置，或引擎向命令行暴露所有选项中的一个子集
  - 环境变量
  - 线上用户设定文档：将成就、已购买或已解锁的游戏内容、游戏选项及其他信息存储与中央服务器，只要能够访问互联网，无论何地都可以读取数据

#### 5.5.2 个别用户选项

- 多数游戏引擎会区分全局选项和个别用户选项，允许开发者和用户自定义工作和游戏环境
- 存储个别用户选项必须特别小心，保证每个玩家只能“看见”自己的选项，而不会遇见其他玩家在同一计算机上的选项

#### 5.5.3 真实引擎中的配置管理

















